import { AfterContentInit, ElementRef, EventEmitter } from "@angular/core";
import { DatetimeAdapter } from "../adapter/datetime-adapter";
import { MatDatetimepickerFilterType } from "./datetimepicker-filtertype";
import * as ɵngcc0 from '@angular/core';
export declare const CLOCK_RADIUS = 50;
export declare const CLOCK_INNER_RADIUS = 27.5;
export declare const CLOCK_OUTER_RADIUS = 41.25;
export declare const CLOCK_TICK_RADIUS = 7.0833;
export declare type MatClockView = "hour" | "minute";
/**
 * A clock that is used as part of the datepicker.
 * @docs-private
 */
export declare class MatDatetimepickerClock<D> implements AfterContentInit {
    private _element;
    private _adapter;
    _userSelection: EventEmitter<void>;
    /** A function used to filter which dates are selectable. */
    dateFilter: (date: D, type: MatDatetimepickerFilterType) => boolean;
    interval: number;
    twelvehour: boolean;
    /** Emits when the currently selected date changes. */
    selectedChange: EventEmitter<D>;
    activeDateChange: EventEmitter<D>;
    /** Hours and Minutes representing the clock view. */
    _hours: Array<Object>;
    _minutes: Array<Object>;
    /** Whether the clock is in hour view. */
    _hourView: boolean;
    _selectedHour: number;
    _selectedMinute: number;
    private _timeChanged;
    private mouseMoveListener;
    private mouseUpListener;
    constructor(_element: ElementRef, _adapter: DatetimeAdapter<D>);
    private _activeDate;
    /**
     * The date to display in this clock view.
     */
    get activeDate(): D;
    set activeDate(value: D);
    private _selected;
    /** The currently selected date. */
    get selected(): D | null;
    set selected(value: D | null);
    private _minDate;
    /** The minimum selectable date. */
    get minDate(): D | null;
    set minDate(value: D | null);
    private _maxDate;
    /** The maximum selectable date. */
    get maxDate(): D | null;
    set maxDate(value: D | null);
    /** Whether the clock should be started in hour or minute view. */
    set startView(value: MatClockView);
    get _hand(): any;
    ngAfterContentInit(): void;
    /** Handles mousedown events on the clock body. */
    _handleMousedown(event: any): void;
    _handleMousemove(event: any): void;
    _handleMouseup(): void;
    /** Initializes this clock view. */
    private _init;
    /**
     * Set Time
     * @param event
     */
    private setTime;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<MatDatetimepickerClock<any>, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<MatDatetimepickerClock<any>, "mat-datetimepicker-clock", never, { "interval": "interval"; "twelvehour": "twelvehour"; "activeDate": "activeDate"; "selected": "selected"; "minDate": "minDate"; "maxDate": "maxDate"; "startView": "startView"; "dateFilter": "dateFilter"; }, { "_userSelection": "_userSelection"; "selectedChange": "selectedChange"; "activeDateChange": "activeDateChange"; }, never, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xvY2suZC50cyIsInNvdXJjZXMiOlsiY2xvY2suZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWZ0ZXJDb250ZW50SW5pdCwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyIH0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcclxuaW1wb3J0IHsgRGF0ZXRpbWVBZGFwdGVyIH0gZnJvbSBcIi4uL2FkYXB0ZXIvZGF0ZXRpbWUtYWRhcHRlclwiO1xyXG5pbXBvcnQgeyBNYXREYXRldGltZXBpY2tlckZpbHRlclR5cGUgfSBmcm9tIFwiLi9kYXRldGltZXBpY2tlci1maWx0ZXJ0eXBlXCI7XHJcbmV4cG9ydCBkZWNsYXJlIGNvbnN0IENMT0NLX1JBRElVUyA9IDUwO1xyXG5leHBvcnQgZGVjbGFyZSBjb25zdCBDTE9DS19JTk5FUl9SQURJVVMgPSAyNy41O1xyXG5leHBvcnQgZGVjbGFyZSBjb25zdCBDTE9DS19PVVRFUl9SQURJVVMgPSA0MS4yNTtcclxuZXhwb3J0IGRlY2xhcmUgY29uc3QgQ0xPQ0tfVElDS19SQURJVVMgPSA3LjA4MzM7XHJcbmV4cG9ydCBkZWNsYXJlIHR5cGUgTWF0Q2xvY2tWaWV3ID0gXCJob3VyXCIgfCBcIm1pbnV0ZVwiO1xyXG4vKipcclxuICogQSBjbG9jayB0aGF0IGlzIHVzZWQgYXMgcGFydCBvZiB0aGUgZGF0ZXBpY2tlci5cclxuICogQGRvY3MtcHJpdmF0ZVxyXG4gKi9cclxuZXhwb3J0IGRlY2xhcmUgY2xhc3MgTWF0RGF0ZXRpbWVwaWNrZXJDbG9jazxEPiBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQge1xyXG4gICAgcHJpdmF0ZSBfZWxlbWVudDtcclxuICAgIHByaXZhdGUgX2FkYXB0ZXI7XHJcbiAgICBfdXNlclNlbGVjdGlvbjogRXZlbnRFbWl0dGVyPHZvaWQ+O1xyXG4gICAgLyoqIEEgZnVuY3Rpb24gdXNlZCB0byBmaWx0ZXIgd2hpY2ggZGF0ZXMgYXJlIHNlbGVjdGFibGUuICovXHJcbiAgICBkYXRlRmlsdGVyOiAoZGF0ZTogRCwgdHlwZTogTWF0RGF0ZXRpbWVwaWNrZXJGaWx0ZXJUeXBlKSA9PiBib29sZWFuO1xyXG4gICAgaW50ZXJ2YWw6IG51bWJlcjtcclxuICAgIHR3ZWx2ZWhvdXI6IGJvb2xlYW47XHJcbiAgICAvKiogRW1pdHMgd2hlbiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGRhdGUgY2hhbmdlcy4gKi9cclxuICAgIHNlbGVjdGVkQ2hhbmdlOiBFdmVudEVtaXR0ZXI8RD47XHJcbiAgICBhY3RpdmVEYXRlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8RD47XHJcbiAgICAvKiogSG91cnMgYW5kIE1pbnV0ZXMgcmVwcmVzZW50aW5nIHRoZSBjbG9jayB2aWV3LiAqL1xyXG4gICAgX2hvdXJzOiBBcnJheTxPYmplY3Q+O1xyXG4gICAgX21pbnV0ZXM6IEFycmF5PE9iamVjdD47XHJcbiAgICAvKiogV2hldGhlciB0aGUgY2xvY2sgaXMgaW4gaG91ciB2aWV3LiAqL1xyXG4gICAgX2hvdXJWaWV3OiBib29sZWFuO1xyXG4gICAgX3NlbGVjdGVkSG91cjogbnVtYmVyO1xyXG4gICAgX3NlbGVjdGVkTWludXRlOiBudW1iZXI7XHJcbiAgICBwcml2YXRlIF90aW1lQ2hhbmdlZDtcclxuICAgIHByaXZhdGUgbW91c2VNb3ZlTGlzdGVuZXI7XHJcbiAgICBwcml2YXRlIG1vdXNlVXBMaXN0ZW5lcjtcclxuICAgIGNvbnN0cnVjdG9yKF9lbGVtZW50OiBFbGVtZW50UmVmLCBfYWRhcHRlcjogRGF0ZXRpbWVBZGFwdGVyPEQ+KTtcclxuICAgIHByaXZhdGUgX2FjdGl2ZURhdGU7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBkYXRlIHRvIGRpc3BsYXkgaW4gdGhpcyBjbG9jayB2aWV3LlxyXG4gICAgICovXHJcbiAgICBnZXQgYWN0aXZlRGF0ZSgpOiBEO1xyXG4gICAgc2V0IGFjdGl2ZURhdGUodmFsdWU6IEQpO1xyXG4gICAgcHJpdmF0ZSBfc2VsZWN0ZWQ7XHJcbiAgICAvKiogVGhlIGN1cnJlbnRseSBzZWxlY3RlZCBkYXRlLiAqL1xyXG4gICAgZ2V0IHNlbGVjdGVkKCk6IEQgfCBudWxsO1xyXG4gICAgc2V0IHNlbGVjdGVkKHZhbHVlOiBEIHwgbnVsbCk7XHJcbiAgICBwcml2YXRlIF9taW5EYXRlO1xyXG4gICAgLyoqIFRoZSBtaW5pbXVtIHNlbGVjdGFibGUgZGF0ZS4gKi9cclxuICAgIGdldCBtaW5EYXRlKCk6IEQgfCBudWxsO1xyXG4gICAgc2V0IG1pbkRhdGUodmFsdWU6IEQgfCBudWxsKTtcclxuICAgIHByaXZhdGUgX21heERhdGU7XHJcbiAgICAvKiogVGhlIG1heGltdW0gc2VsZWN0YWJsZSBkYXRlLiAqL1xyXG4gICAgZ2V0IG1heERhdGUoKTogRCB8IG51bGw7XHJcbiAgICBzZXQgbWF4RGF0ZSh2YWx1ZTogRCB8IG51bGwpO1xyXG4gICAgLyoqIFdoZXRoZXIgdGhlIGNsb2NrIHNob3VsZCBiZSBzdGFydGVkIGluIGhvdXIgb3IgbWludXRlIHZpZXcuICovXHJcbiAgICBzZXQgc3RhcnRWaWV3KHZhbHVlOiBNYXRDbG9ja1ZpZXcpO1xyXG4gICAgZ2V0IF9oYW5kKCk6IGFueTtcclxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkO1xyXG4gICAgLyoqIEhhbmRsZXMgbW91c2Vkb3duIGV2ZW50cyBvbiB0aGUgY2xvY2sgYm9keS4gKi9cclxuICAgIF9oYW5kbGVNb3VzZWRvd24oZXZlbnQ6IGFueSk6IHZvaWQ7XHJcbiAgICBfaGFuZGxlTW91c2Vtb3ZlKGV2ZW50OiBhbnkpOiB2b2lkO1xyXG4gICAgX2hhbmRsZU1vdXNldXAoKTogdm9pZDtcclxuICAgIC8qKiBJbml0aWFsaXplcyB0aGlzIGNsb2NrIHZpZXcuICovXHJcbiAgICBwcml2YXRlIF9pbml0O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgVGltZVxyXG4gICAgICogQHBhcmFtIGV2ZW50XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc2V0VGltZTtcclxufVxyXG4iXX0=