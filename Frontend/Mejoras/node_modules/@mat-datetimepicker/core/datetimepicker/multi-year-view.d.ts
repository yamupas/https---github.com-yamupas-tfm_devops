import { AfterContentInit, EventEmitter } from "@angular/core";
import { MatDatetimepickerType } from "./datetimepicker";
import { MatDatetimepickerCalendarCell } from "./calendar-body";
import { MatDatetimeFormats } from "../adapter/datetime-formats";
import { DatetimeAdapter } from "../adapter/datetime-adapter";
import * as ɵngcc0 from '@angular/core';
export declare const yearsPerPage = 24;
export declare const yearsPerRow = 4;
/**
 * An internal component used to display multiple years in the datepicker.
 * @docs-private
 */
export declare class MatDatetimepickerMultiYearView<D> implements AfterContentInit {
    _adapter: DatetimeAdapter<D>;
    private _dateFormats;
    _userSelection: EventEmitter<void>;
    type: MatDatetimepickerType;
    /** A function used to filter which dates are selectable. */
    dateFilter: (date: D) => boolean;
    /** Emits when a new month is selected. */
    selectedChange: EventEmitter<D>;
    /** Grid of calendar cells representing the years in the range. */
    _years: MatDatetimepickerCalendarCell[][];
    /** The label for this year range (e.g. "2000-2020"). */
    _yearLabel: string;
    /** The year in this range that today falls on. Null if today is in a different range. */
    _todayYear: number;
    /**
     * The year in this range that the selected Date falls on.
     * Null if the selected Date is in a different range.
     */
    _selectedYear: number | null;
    _calendarState: string;
    constructor(_adapter: DatetimeAdapter<D>, _dateFormats: MatDatetimeFormats);
    private _activeDate;
    /** The date to display in this multi year view*/
    get activeDate(): D;
    set activeDate(value: D);
    private _selected;
    /** The currently selected date. */
    get selected(): D;
    set selected(value: D);
    private _minDate;
    /** The minimum selectable date. */
    get minDate(): D | null;
    set minDate(value: D | null);
    private _maxDate;
    /** The maximum selectable date. */
    get maxDate(): D | null;
    set maxDate(value: D | null);
    ngAfterContentInit(): void;
    /** Handles when a new year is selected. */
    _yearSelected(year: number): void;
    _getActiveCell(): number;
    _calendarStateDone(): void;
    /** Initializes this year view. */
    private _init;
    /** Creates an MatDatetimepickerCalendarCell for the given year. */
    private _createCellForYear;
    /** Whether the given year is enabled. */
    private _shouldEnableYear;
    /**
     * Gets the year in this years range that the given Date falls on.
     * Returns null if the given Date is not in this range.
     */
    private _getYearInCurrentRange;
    /**
     * Validate if the current year is in the current range
     * Returns true if is in range else returns false
     */
    private _isInRange;
    /**
     * @param obj The object to check.
     * @returns The given object if it is both a date instance and valid, otherwise null.
     */
    private _getValidDateOrNull;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<MatDatetimepickerMultiYearView<any>, [{ optional: true; }, { optional: true; }]>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<MatDatetimepickerMultiYearView<any>, "mat-datetimepicker-multi-year-view", never, { "type": "type"; "activeDate": "activeDate"; "selected": "selected"; "minDate": "minDate"; "maxDate": "maxDate"; "dateFilter": "dateFilter"; }, { "_userSelection": "_userSelection"; "selectedChange": "selectedChange"; }, never, never>;
}
export declare function isSameMultiYearView<D>(dateAdapter: DatetimeAdapter<D>, date1: D, date2: D, minDate: D | null, maxDate: D | null): boolean;
/**
 * When the multi-year view is first opened, the active year will be in view.
 * So we compute how many years are between the active year and the *slot* where our
 * "startingYear" will render when paged into view.
 */
export declare function getActiveOffset<D>(dateAdapter: DatetimeAdapter<D>, activeDate: D, minDate: D | null, maxDate: D | null): number;

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibXVsdGkteWVhci12aWV3LmQudHMiLCJzb3VyY2VzIjpbIm11bHRpLXllYXItdmlldy5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBZnRlckNvbnRlbnRJbml0LCBFdmVudEVtaXR0ZXIgfSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xyXG5pbXBvcnQgeyBNYXREYXRldGltZXBpY2tlclR5cGUgfSBmcm9tIFwiLi9kYXRldGltZXBpY2tlclwiO1xyXG5pbXBvcnQgeyBNYXREYXRldGltZXBpY2tlckNhbGVuZGFyQ2VsbCB9IGZyb20gXCIuL2NhbGVuZGFyLWJvZHlcIjtcclxuaW1wb3J0IHsgTWF0RGF0ZXRpbWVGb3JtYXRzIH0gZnJvbSBcIi4uL2FkYXB0ZXIvZGF0ZXRpbWUtZm9ybWF0c1wiO1xyXG5pbXBvcnQgeyBEYXRldGltZUFkYXB0ZXIgfSBmcm9tIFwiLi4vYWRhcHRlci9kYXRldGltZS1hZGFwdGVyXCI7XHJcbmV4cG9ydCBkZWNsYXJlIGNvbnN0IHllYXJzUGVyUGFnZSA9IDI0O1xyXG5leHBvcnQgZGVjbGFyZSBjb25zdCB5ZWFyc1BlclJvdyA9IDQ7XHJcbi8qKlxyXG4gKiBBbiBpbnRlcm5hbCBjb21wb25lbnQgdXNlZCB0byBkaXNwbGF5IG11bHRpcGxlIHllYXJzIGluIHRoZSBkYXRlcGlja2VyLlxyXG4gKiBAZG9jcy1wcml2YXRlXHJcbiAqL1xyXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBNYXREYXRldGltZXBpY2tlck11bHRpWWVhclZpZXc8RD4gaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0IHtcclxuICAgIF9hZGFwdGVyOiBEYXRldGltZUFkYXB0ZXI8RD47XHJcbiAgICBwcml2YXRlIF9kYXRlRm9ybWF0cztcclxuICAgIF91c2VyU2VsZWN0aW9uOiBFdmVudEVtaXR0ZXI8dm9pZD47XHJcbiAgICB0eXBlOiBNYXREYXRldGltZXBpY2tlclR5cGU7XHJcbiAgICAvKiogQSBmdW5jdGlvbiB1c2VkIHRvIGZpbHRlciB3aGljaCBkYXRlcyBhcmUgc2VsZWN0YWJsZS4gKi9cclxuICAgIGRhdGVGaWx0ZXI6IChkYXRlOiBEKSA9PiBib29sZWFuO1xyXG4gICAgLyoqIEVtaXRzIHdoZW4gYSBuZXcgbW9udGggaXMgc2VsZWN0ZWQuICovXHJcbiAgICBzZWxlY3RlZENoYW5nZTogRXZlbnRFbWl0dGVyPEQ+O1xyXG4gICAgLyoqIEdyaWQgb2YgY2FsZW5kYXIgY2VsbHMgcmVwcmVzZW50aW5nIHRoZSB5ZWFycyBpbiB0aGUgcmFuZ2UuICovXHJcbiAgICBfeWVhcnM6IE1hdERhdGV0aW1lcGlja2VyQ2FsZW5kYXJDZWxsW11bXTtcclxuICAgIC8qKiBUaGUgbGFiZWwgZm9yIHRoaXMgeWVhciByYW5nZSAoZS5nLiBcIjIwMDAtMjAyMFwiKS4gKi9cclxuICAgIF95ZWFyTGFiZWw6IHN0cmluZztcclxuICAgIC8qKiBUaGUgeWVhciBpbiB0aGlzIHJhbmdlIHRoYXQgdG9kYXkgZmFsbHMgb24uIE51bGwgaWYgdG9kYXkgaXMgaW4gYSBkaWZmZXJlbnQgcmFuZ2UuICovXHJcbiAgICBfdG9kYXlZZWFyOiBudW1iZXI7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSB5ZWFyIGluIHRoaXMgcmFuZ2UgdGhhdCB0aGUgc2VsZWN0ZWQgRGF0ZSBmYWxscyBvbi5cclxuICAgICAqIE51bGwgaWYgdGhlIHNlbGVjdGVkIERhdGUgaXMgaW4gYSBkaWZmZXJlbnQgcmFuZ2UuXHJcbiAgICAgKi9cclxuICAgIF9zZWxlY3RlZFllYXI6IG51bWJlciB8IG51bGw7XHJcbiAgICBfY2FsZW5kYXJTdGF0ZTogc3RyaW5nO1xyXG4gICAgY29uc3RydWN0b3IoX2FkYXB0ZXI6IERhdGV0aW1lQWRhcHRlcjxEPiwgX2RhdGVGb3JtYXRzOiBNYXREYXRldGltZUZvcm1hdHMpO1xyXG4gICAgcHJpdmF0ZSBfYWN0aXZlRGF0ZTtcclxuICAgIC8qKiBUaGUgZGF0ZSB0byBkaXNwbGF5IGluIHRoaXMgbXVsdGkgeWVhciB2aWV3Ki9cclxuICAgIGdldCBhY3RpdmVEYXRlKCk6IEQ7XHJcbiAgICBzZXQgYWN0aXZlRGF0ZSh2YWx1ZTogRCk7XHJcbiAgICBwcml2YXRlIF9zZWxlY3RlZDtcclxuICAgIC8qKiBUaGUgY3VycmVudGx5IHNlbGVjdGVkIGRhdGUuICovXHJcbiAgICBnZXQgc2VsZWN0ZWQoKTogRDtcclxuICAgIHNldCBzZWxlY3RlZCh2YWx1ZTogRCk7XHJcbiAgICBwcml2YXRlIF9taW5EYXRlO1xyXG4gICAgLyoqIFRoZSBtaW5pbXVtIHNlbGVjdGFibGUgZGF0ZS4gKi9cclxuICAgIGdldCBtaW5EYXRlKCk6IEQgfCBudWxsO1xyXG4gICAgc2V0IG1pbkRhdGUodmFsdWU6IEQgfCBudWxsKTtcclxuICAgIHByaXZhdGUgX21heERhdGU7XHJcbiAgICAvKiogVGhlIG1heGltdW0gc2VsZWN0YWJsZSBkYXRlLiAqL1xyXG4gICAgZ2V0IG1heERhdGUoKTogRCB8IG51bGw7XHJcbiAgICBzZXQgbWF4RGF0ZSh2YWx1ZTogRCB8IG51bGwpO1xyXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQ7XHJcbiAgICAvKiogSGFuZGxlcyB3aGVuIGEgbmV3IHllYXIgaXMgc2VsZWN0ZWQuICovXHJcbiAgICBfeWVhclNlbGVjdGVkKHllYXI6IG51bWJlcik6IHZvaWQ7XHJcbiAgICBfZ2V0QWN0aXZlQ2VsbCgpOiBudW1iZXI7XHJcbiAgICBfY2FsZW5kYXJTdGF0ZURvbmUoKTogdm9pZDtcclxuICAgIC8qKiBJbml0aWFsaXplcyB0aGlzIHllYXIgdmlldy4gKi9cclxuICAgIHByaXZhdGUgX2luaXQ7XHJcbiAgICAvKiogQ3JlYXRlcyBhbiBNYXREYXRldGltZXBpY2tlckNhbGVuZGFyQ2VsbCBmb3IgdGhlIGdpdmVuIHllYXIuICovXHJcbiAgICBwcml2YXRlIF9jcmVhdGVDZWxsRm9yWWVhcjtcclxuICAgIC8qKiBXaGV0aGVyIHRoZSBnaXZlbiB5ZWFyIGlzIGVuYWJsZWQuICovXHJcbiAgICBwcml2YXRlIF9zaG91bGRFbmFibGVZZWFyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSB5ZWFyIGluIHRoaXMgeWVhcnMgcmFuZ2UgdGhhdCB0aGUgZ2l2ZW4gRGF0ZSBmYWxscyBvbi5cclxuICAgICAqIFJldHVybnMgbnVsbCBpZiB0aGUgZ2l2ZW4gRGF0ZSBpcyBub3QgaW4gdGhpcyByYW5nZS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBfZ2V0WWVhckluQ3VycmVudFJhbmdlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBWYWxpZGF0ZSBpZiB0aGUgY3VycmVudCB5ZWFyIGlzIGluIHRoZSBjdXJyZW50IHJhbmdlXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgaXMgaW4gcmFuZ2UgZWxzZSByZXR1cm5zIGZhbHNlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgX2lzSW5SYW5nZTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIG9iaiBUaGUgb2JqZWN0IHRvIGNoZWNrLlxyXG4gICAgICogQHJldHVybnMgVGhlIGdpdmVuIG9iamVjdCBpZiBpdCBpcyBib3RoIGEgZGF0ZSBpbnN0YW5jZSBhbmQgdmFsaWQsIG90aGVyd2lzZSBudWxsLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIF9nZXRWYWxpZERhdGVPck51bGw7XHJcbn1cclxuZXhwb3J0IGRlY2xhcmUgZnVuY3Rpb24gaXNTYW1lTXVsdGlZZWFyVmlldzxEPihkYXRlQWRhcHRlcjogRGF0ZXRpbWVBZGFwdGVyPEQ+LCBkYXRlMTogRCwgZGF0ZTI6IEQsIG1pbkRhdGU6IEQgfCBudWxsLCBtYXhEYXRlOiBEIHwgbnVsbCk6IGJvb2xlYW47XHJcbi8qKlxyXG4gKiBXaGVuIHRoZSBtdWx0aS15ZWFyIHZpZXcgaXMgZmlyc3Qgb3BlbmVkLCB0aGUgYWN0aXZlIHllYXIgd2lsbCBiZSBpbiB2aWV3LlxyXG4gKiBTbyB3ZSBjb21wdXRlIGhvdyBtYW55IHllYXJzIGFyZSBiZXR3ZWVuIHRoZSBhY3RpdmUgeWVhciBhbmQgdGhlICpzbG90KiB3aGVyZSBvdXJcclxuICogXCJzdGFydGluZ1llYXJcIiB3aWxsIHJlbmRlciB3aGVuIHBhZ2VkIGludG8gdmlldy5cclxuICovXHJcbmV4cG9ydCBkZWNsYXJlIGZ1bmN0aW9uIGdldEFjdGl2ZU9mZnNldDxEPihkYXRlQWRhcHRlcjogRGF0ZXRpbWVBZGFwdGVyPEQ+LCBhY3RpdmVEYXRlOiBELCBtaW5EYXRlOiBEIHwgbnVsbCwgbWF4RGF0ZTogRCB8IG51bGwpOiBudW1iZXI7XHJcbiJdfQ==