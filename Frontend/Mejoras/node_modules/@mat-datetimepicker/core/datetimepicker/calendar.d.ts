import { AfterContentInit, ChangeDetectorRef, ElementRef, EventEmitter, NgZone, OnDestroy } from "@angular/core";
import { MatDatepickerIntl } from "@angular/material/datepicker";
import { DatetimeAdapter } from "../adapter/datetime-adapter";
import { MatDatetimeFormats } from "../adapter/datetime-formats";
import { MatClockView } from "./clock";
import { MatDatetimepickerType } from "./datetimepicker";
import { MatDatetimepickerFilterType } from "./datetimepicker-filtertype";
import * as ɵngcc0 from '@angular/core';
export declare type MatCalendarView = "clock" | "month" | "year" | "multi-year";
/**
 * A calendar that is used as part of the datepicker.
 * @docs-private
 */
export declare class MatDatetimepickerCalendar<D> implements AfterContentInit, OnDestroy {
    private _elementRef;
    private _intl;
    private _ngZone;
    private _adapter;
    private _dateFormats;
    _userSelection: EventEmitter<void>;
    /** Active multi year view when click on year. */
    multiYearSelector: boolean;
    /** Whether the calendar should be started in month or year view. */
    startView: MatCalendarView;
    twelvehour: boolean;
    timeInterval: number;
    /** A function used to filter which dates are selectable. */
    dateFilter: (date: D, type: MatDatetimepickerFilterType) => boolean;
    ariaLabel: string;
    ariaNextMonthLabel: string;
    ariaPrevMonthLabel: string;
    ariaNextYearLabel: string;
    ariaPrevYearLabel: string;
    ariaNextMultiYearLabel: string;
    ariaPrevMultiYearLabel: string;
    /** Emits when the currently selected date changes. */
    selectedChange: EventEmitter<D>;
    /** Emits when the view has been changed. **/
    viewChanged: EventEmitter<MatCalendarView>;
    _AMPM: string;
    _clockView: MatClockView;
    _calendarState: string;
    private _intlChanges;
    private _clampedActiveDate;
    constructor(_elementRef: ElementRef, _intl: MatDatepickerIntl, _ngZone: NgZone, _adapter: DatetimeAdapter<D>, _dateFormats: MatDatetimeFormats, changeDetectorRef: ChangeDetectorRef);
    private _type;
    get type(): MatDatetimepickerType;
    set type(value: MatDatetimepickerType);
    private _startAt;
    /** A date representing the period (month or year) to start the calendar in. */
    get startAt(): D | null;
    set startAt(value: D | null);
    private _selected;
    /** The currently selected date. */
    get selected(): D | null;
    set selected(value: D | null);
    private _minDate;
    /** The minimum selectable date. */
    get minDate(): D | null;
    set minDate(value: D | null);
    private _maxDate;
    /** The maximum selectable date. */
    get maxDate(): D | null;
    set maxDate(value: D | null);
    /**
     * The current active date. This determines which time period is shown and which date is
     * highlighted when using keyboard navigation.
     */
    get _activeDate(): D;
    set _activeDate(value: D);
    /** Whether the calendar is in month view. */
    _currentView: MatCalendarView;
    get currentView(): MatCalendarView;
    set currentView(view: MatCalendarView);
    /** The label for the current calendar view. */
    get _yearLabel(): string;
    get _monthYearLabel(): string;
    get _dateLabel(): string;
    get _hoursLabel(): string;
    get _minutesLabel(): string;
    get _ariaLabelNext(): string;
    get _ariaLabelPrev(): string;
    /** Date filter for the month and year views. */
    _dateFilterForViews: (date: D) => boolean;
    _userSelected(): void;
    ngAfterContentInit(): void;
    ngOnDestroy(): void;
    /** Handles date selection in the month view. */
    _dateSelected(date: D): void;
    /** Handles month selection in the year view. */
    _monthSelected(month: D): void;
    /** Handles year selection in the multi year view. */
    _yearSelected(year: D): void;
    _timeSelected(date: D): void;
    _onActiveDateChange(date: D): void;
    _updateDate(date: D): D;
    _selectAMPM(date: D): void;
    _ampmClicked(source: string): void;
    _yearClicked(): void;
    _dateClicked(): void;
    _hoursClicked(): void;
    _minutesClicked(): void;
    /** Handles user clicks on the previous button. */
    _previousClicked(): void;
    /** Handles user clicks on the next button. */
    _nextClicked(): void;
    /** Whether the previous period button is enabled. */
    _previousEnabled(): boolean;
    /** Whether the next period button is enabled. */
    _nextEnabled(): boolean;
    /** Handles keydown events on the calendar body. */
    _handleCalendarBodyKeydown(event: KeyboardEvent): void;
    _focusActiveCell(): void;
    _calendarStateDone(): void;
    /** Whether the two dates represent the same view in the current view mode (month or year). */
    private _isSameView;
    /** Handles keydown events on the calendar body when calendar is in month view. */
    private _handleCalendarBodyKeydownInMonthView;
    /** Handles keydown events on the calendar body when calendar is in year view. */
    private _handleCalendarBodyKeydownInYearView;
    /** Handles keydown events on the calendar body when calendar is in multi-year view. */
    private _handleCalendarBodyKeydownInMultiYearView;
    /** Handles keydown events on the calendar body when calendar is in month view. */
    private _handleCalendarBodyKeydownInClockView;
    /**
     * Determine the date for the month that comes before the given month in the same column in the
     * calendar table.
     */
    private _prevMonthInSameCol;
    /**
     * Determine the date for the month that comes after the given month in the same column in the
     * calendar table.
     */
    private _nextMonthInSameCol;
    private calendarState;
    private _2digit;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<MatDatetimepickerCalendar<any>, [null, null, null, { optional: true; }, { optional: true; }, null]>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<MatDatetimepickerCalendar<any>, "mat-datetimepicker-calendar", never, { "multiYearSelector": "multiYearSelector"; "startView": "startView"; "twelvehour": "twelvehour"; "timeInterval": "timeInterval"; "ariaLabel": "ariaLabel"; "ariaNextMonthLabel": "ariaNextMonthLabel"; "ariaPrevMonthLabel": "ariaPrevMonthLabel"; "ariaNextYearLabel": "ariaNextYearLabel"; "ariaPrevYearLabel": "ariaPrevYearLabel"; "ariaNextMultiYearLabel": "ariaNextMultiYearLabel"; "ariaPrevMultiYearLabel": "ariaPrevMultiYearLabel"; "type": "type"; "startAt": "startAt"; "selected": "selected"; "minDate": "minDate"; "maxDate": "maxDate"; "dateFilter": "dateFilter"; }, { "_userSelection": "_userSelection"; "selectedChange": "selectedChange"; "viewChanged": "viewChanged"; }, never, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FsZW5kYXIuZC50cyIsInNvdXJjZXMiOlsiY2FsZW5kYXIuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFmdGVyQ29udGVudEluaXQsIENoYW5nZURldGVjdG9yUmVmLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIE5nWm9uZSwgT25EZXN0cm95IH0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcclxuaW1wb3J0IHsgTWF0RGF0ZXBpY2tlckludGwgfSBmcm9tIFwiQGFuZ3VsYXIvbWF0ZXJpYWwvZGF0ZXBpY2tlclwiO1xyXG5pbXBvcnQgeyBEYXRldGltZUFkYXB0ZXIgfSBmcm9tIFwiLi4vYWRhcHRlci9kYXRldGltZS1hZGFwdGVyXCI7XHJcbmltcG9ydCB7IE1hdERhdGV0aW1lRm9ybWF0cyB9IGZyb20gXCIuLi9hZGFwdGVyL2RhdGV0aW1lLWZvcm1hdHNcIjtcclxuaW1wb3J0IHsgTWF0Q2xvY2tWaWV3IH0gZnJvbSBcIi4vY2xvY2tcIjtcclxuaW1wb3J0IHsgTWF0RGF0ZXRpbWVwaWNrZXJUeXBlIH0gZnJvbSBcIi4vZGF0ZXRpbWVwaWNrZXJcIjtcclxuaW1wb3J0IHsgTWF0RGF0ZXRpbWVwaWNrZXJGaWx0ZXJUeXBlIH0gZnJvbSBcIi4vZGF0ZXRpbWVwaWNrZXItZmlsdGVydHlwZVwiO1xyXG5leHBvcnQgZGVjbGFyZSB0eXBlIE1hdENhbGVuZGFyVmlldyA9IFwiY2xvY2tcIiB8IFwibW9udGhcIiB8IFwieWVhclwiIHwgXCJtdWx0aS15ZWFyXCI7XHJcbi8qKlxyXG4gKiBBIGNhbGVuZGFyIHRoYXQgaXMgdXNlZCBhcyBwYXJ0IG9mIHRoZSBkYXRlcGlja2VyLlxyXG4gKiBAZG9jcy1wcml2YXRlXHJcbiAqL1xyXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBNYXREYXRldGltZXBpY2tlckNhbGVuZGFyPEQ+IGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCwgT25EZXN0cm95IHtcclxuICAgIHByaXZhdGUgX2VsZW1lbnRSZWY7XHJcbiAgICBwcml2YXRlIF9pbnRsO1xyXG4gICAgcHJpdmF0ZSBfbmdab25lO1xyXG4gICAgcHJpdmF0ZSBfYWRhcHRlcjtcclxuICAgIHByaXZhdGUgX2RhdGVGb3JtYXRzO1xyXG4gICAgX3VzZXJTZWxlY3Rpb246IEV2ZW50RW1pdHRlcjx2b2lkPjtcclxuICAgIC8qKiBBY3RpdmUgbXVsdGkgeWVhciB2aWV3IHdoZW4gY2xpY2sgb24geWVhci4gKi9cclxuICAgIG11bHRpWWVhclNlbGVjdG9yOiBib29sZWFuO1xyXG4gICAgLyoqIFdoZXRoZXIgdGhlIGNhbGVuZGFyIHNob3VsZCBiZSBzdGFydGVkIGluIG1vbnRoIG9yIHllYXIgdmlldy4gKi9cclxuICAgIHN0YXJ0VmlldzogTWF0Q2FsZW5kYXJWaWV3O1xyXG4gICAgdHdlbHZlaG91cjogYm9vbGVhbjtcclxuICAgIHRpbWVJbnRlcnZhbDogbnVtYmVyO1xyXG4gICAgLyoqIEEgZnVuY3Rpb24gdXNlZCB0byBmaWx0ZXIgd2hpY2ggZGF0ZXMgYXJlIHNlbGVjdGFibGUuICovXHJcbiAgICBkYXRlRmlsdGVyOiAoZGF0ZTogRCwgdHlwZTogTWF0RGF0ZXRpbWVwaWNrZXJGaWx0ZXJUeXBlKSA9PiBib29sZWFuO1xyXG4gICAgYXJpYUxhYmVsOiBzdHJpbmc7XHJcbiAgICBhcmlhTmV4dE1vbnRoTGFiZWw6IHN0cmluZztcclxuICAgIGFyaWFQcmV2TW9udGhMYWJlbDogc3RyaW5nO1xyXG4gICAgYXJpYU5leHRZZWFyTGFiZWw6IHN0cmluZztcclxuICAgIGFyaWFQcmV2WWVhckxhYmVsOiBzdHJpbmc7XHJcbiAgICBhcmlhTmV4dE11bHRpWWVhckxhYmVsOiBzdHJpbmc7XHJcbiAgICBhcmlhUHJldk11bHRpWWVhckxhYmVsOiBzdHJpbmc7XHJcbiAgICAvKiogRW1pdHMgd2hlbiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGRhdGUgY2hhbmdlcy4gKi9cclxuICAgIHNlbGVjdGVkQ2hhbmdlOiBFdmVudEVtaXR0ZXI8RD47XHJcbiAgICAvKiogRW1pdHMgd2hlbiB0aGUgdmlldyBoYXMgYmVlbiBjaGFuZ2VkLiAqKi9cclxuICAgIHZpZXdDaGFuZ2VkOiBFdmVudEVtaXR0ZXI8TWF0Q2FsZW5kYXJWaWV3PjtcclxuICAgIF9BTVBNOiBzdHJpbmc7XHJcbiAgICBfY2xvY2tWaWV3OiBNYXRDbG9ja1ZpZXc7XHJcbiAgICBfY2FsZW5kYXJTdGF0ZTogc3RyaW5nO1xyXG4gICAgcHJpdmF0ZSBfaW50bENoYW5nZXM7XHJcbiAgICBwcml2YXRlIF9jbGFtcGVkQWN0aXZlRGF0ZTtcclxuICAgIGNvbnN0cnVjdG9yKF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLCBfaW50bDogTWF0RGF0ZXBpY2tlckludGwsIF9uZ1pvbmU6IE5nWm9uZSwgX2FkYXB0ZXI6IERhdGV0aW1lQWRhcHRlcjxEPiwgX2RhdGVGb3JtYXRzOiBNYXREYXRldGltZUZvcm1hdHMsIGNoYW5nZURldGVjdG9yUmVmOiBDaGFuZ2VEZXRlY3RvclJlZik7XHJcbiAgICBwcml2YXRlIF90eXBlO1xyXG4gICAgZ2V0IHR5cGUoKTogTWF0RGF0ZXRpbWVwaWNrZXJUeXBlO1xyXG4gICAgc2V0IHR5cGUodmFsdWU6IE1hdERhdGV0aW1lcGlja2VyVHlwZSk7XHJcbiAgICBwcml2YXRlIF9zdGFydEF0O1xyXG4gICAgLyoqIEEgZGF0ZSByZXByZXNlbnRpbmcgdGhlIHBlcmlvZCAobW9udGggb3IgeWVhcikgdG8gc3RhcnQgdGhlIGNhbGVuZGFyIGluLiAqL1xyXG4gICAgZ2V0IHN0YXJ0QXQoKTogRCB8IG51bGw7XHJcbiAgICBzZXQgc3RhcnRBdCh2YWx1ZTogRCB8IG51bGwpO1xyXG4gICAgcHJpdmF0ZSBfc2VsZWN0ZWQ7XHJcbiAgICAvKiogVGhlIGN1cnJlbnRseSBzZWxlY3RlZCBkYXRlLiAqL1xyXG4gICAgZ2V0IHNlbGVjdGVkKCk6IEQgfCBudWxsO1xyXG4gICAgc2V0IHNlbGVjdGVkKHZhbHVlOiBEIHwgbnVsbCk7XHJcbiAgICBwcml2YXRlIF9taW5EYXRlO1xyXG4gICAgLyoqIFRoZSBtaW5pbXVtIHNlbGVjdGFibGUgZGF0ZS4gKi9cclxuICAgIGdldCBtaW5EYXRlKCk6IEQgfCBudWxsO1xyXG4gICAgc2V0IG1pbkRhdGUodmFsdWU6IEQgfCBudWxsKTtcclxuICAgIHByaXZhdGUgX21heERhdGU7XHJcbiAgICAvKiogVGhlIG1heGltdW0gc2VsZWN0YWJsZSBkYXRlLiAqL1xyXG4gICAgZ2V0IG1heERhdGUoKTogRCB8IG51bGw7XHJcbiAgICBzZXQgbWF4RGF0ZSh2YWx1ZTogRCB8IG51bGwpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY3VycmVudCBhY3RpdmUgZGF0ZS4gVGhpcyBkZXRlcm1pbmVzIHdoaWNoIHRpbWUgcGVyaW9kIGlzIHNob3duIGFuZCB3aGljaCBkYXRlIGlzXHJcbiAgICAgKiBoaWdobGlnaHRlZCB3aGVuIHVzaW5nIGtleWJvYXJkIG5hdmlnYXRpb24uXHJcbiAgICAgKi9cclxuICAgIGdldCBfYWN0aXZlRGF0ZSgpOiBEO1xyXG4gICAgc2V0IF9hY3RpdmVEYXRlKHZhbHVlOiBEKTtcclxuICAgIC8qKiBXaGV0aGVyIHRoZSBjYWxlbmRhciBpcyBpbiBtb250aCB2aWV3LiAqL1xyXG4gICAgX2N1cnJlbnRWaWV3OiBNYXRDYWxlbmRhclZpZXc7XHJcbiAgICBnZXQgY3VycmVudFZpZXcoKTogTWF0Q2FsZW5kYXJWaWV3O1xyXG4gICAgc2V0IGN1cnJlbnRWaWV3KHZpZXc6IE1hdENhbGVuZGFyVmlldyk7XHJcbiAgICAvKiogVGhlIGxhYmVsIGZvciB0aGUgY3VycmVudCBjYWxlbmRhciB2aWV3LiAqL1xyXG4gICAgZ2V0IF95ZWFyTGFiZWwoKTogc3RyaW5nO1xyXG4gICAgZ2V0IF9tb250aFllYXJMYWJlbCgpOiBzdHJpbmc7XHJcbiAgICBnZXQgX2RhdGVMYWJlbCgpOiBzdHJpbmc7XHJcbiAgICBnZXQgX2hvdXJzTGFiZWwoKTogc3RyaW5nO1xyXG4gICAgZ2V0IF9taW51dGVzTGFiZWwoKTogc3RyaW5nO1xyXG4gICAgZ2V0IF9hcmlhTGFiZWxOZXh0KCk6IHN0cmluZztcclxuICAgIGdldCBfYXJpYUxhYmVsUHJldigpOiBzdHJpbmc7XHJcbiAgICAvKiogRGF0ZSBmaWx0ZXIgZm9yIHRoZSBtb250aCBhbmQgeWVhciB2aWV3cy4gKi9cclxuICAgIF9kYXRlRmlsdGVyRm9yVmlld3M6IChkYXRlOiBEKSA9PiBib29sZWFuO1xyXG4gICAgX3VzZXJTZWxlY3RlZCgpOiB2b2lkO1xyXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQ7XHJcbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkO1xyXG4gICAgLyoqIEhhbmRsZXMgZGF0ZSBzZWxlY3Rpb24gaW4gdGhlIG1vbnRoIHZpZXcuICovXHJcbiAgICBfZGF0ZVNlbGVjdGVkKGRhdGU6IEQpOiB2b2lkO1xyXG4gICAgLyoqIEhhbmRsZXMgbW9udGggc2VsZWN0aW9uIGluIHRoZSB5ZWFyIHZpZXcuICovXHJcbiAgICBfbW9udGhTZWxlY3RlZChtb250aDogRCk6IHZvaWQ7XHJcbiAgICAvKiogSGFuZGxlcyB5ZWFyIHNlbGVjdGlvbiBpbiB0aGUgbXVsdGkgeWVhciB2aWV3LiAqL1xyXG4gICAgX3llYXJTZWxlY3RlZCh5ZWFyOiBEKTogdm9pZDtcclxuICAgIF90aW1lU2VsZWN0ZWQoZGF0ZTogRCk6IHZvaWQ7XHJcbiAgICBfb25BY3RpdmVEYXRlQ2hhbmdlKGRhdGU6IEQpOiB2b2lkO1xyXG4gICAgX3VwZGF0ZURhdGUoZGF0ZTogRCk6IEQ7XHJcbiAgICBfc2VsZWN0QU1QTShkYXRlOiBEKTogdm9pZDtcclxuICAgIF9hbXBtQ2xpY2tlZChzb3VyY2U6IHN0cmluZyk6IHZvaWQ7XHJcbiAgICBfeWVhckNsaWNrZWQoKTogdm9pZDtcclxuICAgIF9kYXRlQ2xpY2tlZCgpOiB2b2lkO1xyXG4gICAgX2hvdXJzQ2xpY2tlZCgpOiB2b2lkO1xyXG4gICAgX21pbnV0ZXNDbGlja2VkKCk6IHZvaWQ7XHJcbiAgICAvKiogSGFuZGxlcyB1c2VyIGNsaWNrcyBvbiB0aGUgcHJldmlvdXMgYnV0dG9uLiAqL1xyXG4gICAgX3ByZXZpb3VzQ2xpY2tlZCgpOiB2b2lkO1xyXG4gICAgLyoqIEhhbmRsZXMgdXNlciBjbGlja3Mgb24gdGhlIG5leHQgYnV0dG9uLiAqL1xyXG4gICAgX25leHRDbGlja2VkKCk6IHZvaWQ7XHJcbiAgICAvKiogV2hldGhlciB0aGUgcHJldmlvdXMgcGVyaW9kIGJ1dHRvbiBpcyBlbmFibGVkLiAqL1xyXG4gICAgX3ByZXZpb3VzRW5hYmxlZCgpOiBib29sZWFuO1xyXG4gICAgLyoqIFdoZXRoZXIgdGhlIG5leHQgcGVyaW9kIGJ1dHRvbiBpcyBlbmFibGVkLiAqL1xyXG4gICAgX25leHRFbmFibGVkKCk6IGJvb2xlYW47XHJcbiAgICAvKiogSGFuZGxlcyBrZXlkb3duIGV2ZW50cyBvbiB0aGUgY2FsZW5kYXIgYm9keS4gKi9cclxuICAgIF9oYW5kbGVDYWxlbmRhckJvZHlLZXlkb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZDtcclxuICAgIF9mb2N1c0FjdGl2ZUNlbGwoKTogdm9pZDtcclxuICAgIF9jYWxlbmRhclN0YXRlRG9uZSgpOiB2b2lkO1xyXG4gICAgLyoqIFdoZXRoZXIgdGhlIHR3byBkYXRlcyByZXByZXNlbnQgdGhlIHNhbWUgdmlldyBpbiB0aGUgY3VycmVudCB2aWV3IG1vZGUgKG1vbnRoIG9yIHllYXIpLiAqL1xyXG4gICAgcHJpdmF0ZSBfaXNTYW1lVmlldztcclxuICAgIC8qKiBIYW5kbGVzIGtleWRvd24gZXZlbnRzIG9uIHRoZSBjYWxlbmRhciBib2R5IHdoZW4gY2FsZW5kYXIgaXMgaW4gbW9udGggdmlldy4gKi9cclxuICAgIHByaXZhdGUgX2hhbmRsZUNhbGVuZGFyQm9keUtleWRvd25Jbk1vbnRoVmlldztcclxuICAgIC8qKiBIYW5kbGVzIGtleWRvd24gZXZlbnRzIG9uIHRoZSBjYWxlbmRhciBib2R5IHdoZW4gY2FsZW5kYXIgaXMgaW4geWVhciB2aWV3LiAqL1xyXG4gICAgcHJpdmF0ZSBfaGFuZGxlQ2FsZW5kYXJCb2R5S2V5ZG93bkluWWVhclZpZXc7XHJcbiAgICAvKiogSGFuZGxlcyBrZXlkb3duIGV2ZW50cyBvbiB0aGUgY2FsZW5kYXIgYm9keSB3aGVuIGNhbGVuZGFyIGlzIGluIG11bHRpLXllYXIgdmlldy4gKi9cclxuICAgIHByaXZhdGUgX2hhbmRsZUNhbGVuZGFyQm9keUtleWRvd25Jbk11bHRpWWVhclZpZXc7XHJcbiAgICAvKiogSGFuZGxlcyBrZXlkb3duIGV2ZW50cyBvbiB0aGUgY2FsZW5kYXIgYm9keSB3aGVuIGNhbGVuZGFyIGlzIGluIG1vbnRoIHZpZXcuICovXHJcbiAgICBwcml2YXRlIF9oYW5kbGVDYWxlbmRhckJvZHlLZXlkb3duSW5DbG9ja1ZpZXc7XHJcbiAgICAvKipcclxuICAgICAqIERldGVybWluZSB0aGUgZGF0ZSBmb3IgdGhlIG1vbnRoIHRoYXQgY29tZXMgYmVmb3JlIHRoZSBnaXZlbiBtb250aCBpbiB0aGUgc2FtZSBjb2x1bW4gaW4gdGhlXHJcbiAgICAgKiBjYWxlbmRhciB0YWJsZS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBfcHJldk1vbnRoSW5TYW1lQ29sO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZXRlcm1pbmUgdGhlIGRhdGUgZm9yIHRoZSBtb250aCB0aGF0IGNvbWVzIGFmdGVyIHRoZSBnaXZlbiBtb250aCBpbiB0aGUgc2FtZSBjb2x1bW4gaW4gdGhlXHJcbiAgICAgKiBjYWxlbmRhciB0YWJsZS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBfbmV4dE1vbnRoSW5TYW1lQ29sO1xyXG4gICAgcHJpdmF0ZSBjYWxlbmRhclN0YXRlO1xyXG4gICAgcHJpdmF0ZSBfMmRpZ2l0O1xyXG59XHJcbiJdfQ==