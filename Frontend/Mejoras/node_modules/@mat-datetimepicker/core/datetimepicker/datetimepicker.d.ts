import { Directionality } from "@angular/cdk/bidi";
import { Overlay } from "@angular/cdk/overlay";
import { AfterContentInit, EventEmitter, NgZone, OnDestroy, ViewContainerRef } from "@angular/core";
import { MatDialog } from "@angular/material/dialog";
import { Subject } from "rxjs";
import { DatetimeAdapter } from "../adapter/datetime-adapter";
import { MatCalendarView, MatDatetimepickerCalendar } from "./calendar";
import { MatDatetimepickerFilterType } from "./datetimepicker-filtertype";
import { MatDatetimepickerInput } from "./datetimepicker-input";
import * as ɵngcc0 from '@angular/core';
export declare type MatDatetimepickerType = "date" | "time" | "month" | "year" | "datetime";
export declare type MatDatetimepickerMode = "auto" | "portrait" | "landscape";
/**
 * Component used as the content for the datepicker dialog and popup. We use this instead of using
 * MatCalendar directly as the content so we can control the initial focus. This also gives us a
 * place to put additional features of the popup that are not part of the calendar itself in the
 * future. (e.g. confirmation buttons).
 * @docs-private
 */
export declare class MatDatetimepickerContent<D> implements AfterContentInit {
    datetimepicker: MatDatetimepicker<D>;
    _calendar: MatDatetimepickerCalendar<D>;
    ngAfterContentInit(): void;
    /**
     * Handles keydown event on datepicker content.
     * @param event The event.
     */
    _handleKeydown(event: KeyboardEvent): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<MatDatetimepickerContent<any>, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<MatDatetimepickerContent<any>, "mat-datetimepicker-content", never, {}, {}, never, never>;
}
export declare class MatDatetimepicker<D> implements OnDestroy {
    private _dialog;
    private _overlay;
    private _ngZone;
    private _viewContainerRef;
    private _scrollStrategy;
    private _dateAdapter;
    private _dir;
    private _document;
    /** Active multi year view when click on year. */
    multiYearSelector: boolean;
    /** if true change the clock to 12 hour format. */
    twelvehour: boolean;
    /** The view that the calendar should start in. */
    startView: MatCalendarView;
    mode: MatDatetimepickerMode;
    timeInterval: number;
    ariaNextMonthLabel: string;
    ariaPrevMonthLabel: string;
    ariaNextYearLabel: string;
    ariaPrevYearLabel: string;
    /**
     * Emits new selected date when selected date changes.
     * @deprecated Switch to the `dateChange` and `dateInput` binding on the input element.
     */
    selectedChanged: EventEmitter<D>;
    /** Classes to be passed to the date picker panel. Supports the same syntax as `ngClass`. */
    panelClass: string | string[];
    /** Emits when the datepicker has been opened. */
    openedStream: EventEmitter<void>;
    /** Emits when the datepicker has been closed. */
    closedStream: EventEmitter<void>;
    /** Emits when the view has been changed. **/
    viewChanged: EventEmitter<MatCalendarView>;
    /** Whether the calendar is open. */
    opened: boolean;
    /** The id for the datepicker calendar. */
    id: string;
    /** The input element this datepicker is associated with. */
    _datepickerInput: MatDatetimepickerInput<D>;
    /** Emits when the datepicker is disabled. */
    _disabledChange: Subject<boolean>;
    private _validSelected;
    /** A reference to the overlay when the calendar is opened as a popup. */
    private _popupRef;
    /** A reference to the dialog when the calendar is opened as a dialog. */
    private _dialogRef;
    /** A portal containing the calendar for this datepicker. */
    private _calendarPortal;
    /** The element that was focused before the datepicker was opened. */
    private _focusedElementBeforeOpen;
    private _inputSubscription;
    constructor(_dialog: MatDialog, _overlay: Overlay, _ngZone: NgZone, _viewContainerRef: ViewContainerRef, _scrollStrategy: any, _dateAdapter: DatetimeAdapter<D>, _dir: Directionality, _document: any);
    private _startAt;
    /** The date to open the calendar to initially. */
    get startAt(): D | null;
    set startAt(date: D | null);
    private _openOnFocus;
    get openOnFocus(): boolean;
    set openOnFocus(value: boolean);
    private _type;
    get type(): MatDatetimepickerType;
    set type(value: MatDatetimepickerType);
    private _touchUi;
    /**
     * Whether the calendar UI is in touch mode. In touch mode the calendar opens in a dialog rather
     * than a popup and elements have more padding to allow for bigger touch targets.
     */
    get touchUi(): boolean;
    set touchUi(value: boolean);
    private _disabled;
    /** Whether the datepicker pop-up should be disabled. */
    get disabled(): boolean;
    set disabled(value: boolean);
    /** The currently selected date. */
    get _selected(): D | null;
    set _selected(value: D | null);
    /** The minimum selectable date. */
    get _minDate(): D | null;
    /** The maximum selectable date. */
    get _maxDate(): D | null;
    get _dateFilter(): (date: D | null, type: MatDatetimepickerFilterType) => boolean;
    _handleFocus(): void;
    _viewChanged(type: MatCalendarView): void;
    ngOnDestroy(): void;
    /** Selects the given date */
    _select(date: D): void;
    /**
     * Register an input with this datepicker.
     * @param input The datepicker input to register with this datepicker.
     */
    _registerInput(input: MatDatetimepickerInput<D>): void;
    /** Open the calendar. */
    open(): void;
    /** Close the calendar. */
    close(): void;
    /** Open the calendar as a dialog. */
    private _openAsDialog;
    /** Open the calendar as a popup. */
    private _openAsPopup;
    /** Create the popup. */
    private _createPopup;
    /** Create the popup PositionStrategy. */
    private _createPopupPositionStrategy;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<MatDatetimepicker<any>, [null, null, null, null, null, { optional: true; }, { optional: true; }, { optional: true; }]>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<MatDatetimepicker<any>, "mat-datetimepicker", ["matDatetimepicker"], { "multiYearSelector": "multiYearSelector"; "twelvehour": "twelvehour"; "startView": "startView"; "mode": "mode"; "timeInterval": "timeInterval"; "ariaNextMonthLabel": "ariaNextMonthLabel"; "ariaPrevMonthLabel": "ariaPrevMonthLabel"; "ariaNextYearLabel": "ariaNextYearLabel"; "ariaPrevYearLabel": "ariaPrevYearLabel"; "startAt": "startAt"; "openOnFocus": "openOnFocus"; "type": "type"; "touchUi": "touchUi"; "disabled": "disabled"; "panelClass": "panelClass"; }, { "selectedChanged": "selectedChanged"; "openedStream": "opened"; "closedStream": "closed"; "viewChanged": "viewChanged"; }, never, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZXRpbWVwaWNrZXIuZC50cyIsInNvdXJjZXMiOlsiZGF0ZXRpbWVwaWNrZXIuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGlyZWN0aW9uYWxpdHkgfSBmcm9tIFwiQGFuZ3VsYXIvY2RrL2JpZGlcIjtcclxuaW1wb3J0IHsgT3ZlcmxheSB9IGZyb20gXCJAYW5ndWxhci9jZGsvb3ZlcmxheVwiO1xyXG5pbXBvcnQgeyBBZnRlckNvbnRlbnRJbml0LCBFdmVudEVtaXR0ZXIsIE5nWm9uZSwgT25EZXN0cm95LCBWaWV3Q29udGFpbmVyUmVmIH0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcclxuaW1wb3J0IHsgTWF0RGlhbG9nIH0gZnJvbSBcIkBhbmd1bGFyL21hdGVyaWFsL2RpYWxvZ1wiO1xyXG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSBcInJ4anNcIjtcclxuaW1wb3J0IHsgRGF0ZXRpbWVBZGFwdGVyIH0gZnJvbSBcIi4uL2FkYXB0ZXIvZGF0ZXRpbWUtYWRhcHRlclwiO1xyXG5pbXBvcnQgeyBNYXRDYWxlbmRhclZpZXcsIE1hdERhdGV0aW1lcGlja2VyQ2FsZW5kYXIgfSBmcm9tIFwiLi9jYWxlbmRhclwiO1xyXG5pbXBvcnQgeyBNYXREYXRldGltZXBpY2tlckZpbHRlclR5cGUgfSBmcm9tIFwiLi9kYXRldGltZXBpY2tlci1maWx0ZXJ0eXBlXCI7XHJcbmltcG9ydCB7IE1hdERhdGV0aW1lcGlja2VySW5wdXQgfSBmcm9tIFwiLi9kYXRldGltZXBpY2tlci1pbnB1dFwiO1xyXG5leHBvcnQgZGVjbGFyZSB0eXBlIE1hdERhdGV0aW1lcGlja2VyVHlwZSA9IFwiZGF0ZVwiIHwgXCJ0aW1lXCIgfCBcIm1vbnRoXCIgfCBcInllYXJcIiB8IFwiZGF0ZXRpbWVcIjtcclxuZXhwb3J0IGRlY2xhcmUgdHlwZSBNYXREYXRldGltZXBpY2tlck1vZGUgPSBcImF1dG9cIiB8IFwicG9ydHJhaXRcIiB8IFwibGFuZHNjYXBlXCI7XHJcbi8qKlxyXG4gKiBDb21wb25lbnQgdXNlZCBhcyB0aGUgY29udGVudCBmb3IgdGhlIGRhdGVwaWNrZXIgZGlhbG9nIGFuZCBwb3B1cC4gV2UgdXNlIHRoaXMgaW5zdGVhZCBvZiB1c2luZ1xyXG4gKiBNYXRDYWxlbmRhciBkaXJlY3RseSBhcyB0aGUgY29udGVudCBzbyB3ZSBjYW4gY29udHJvbCB0aGUgaW5pdGlhbCBmb2N1cy4gVGhpcyBhbHNvIGdpdmVzIHVzIGFcclxuICogcGxhY2UgdG8gcHV0IGFkZGl0aW9uYWwgZmVhdHVyZXMgb2YgdGhlIHBvcHVwIHRoYXQgYXJlIG5vdCBwYXJ0IG9mIHRoZSBjYWxlbmRhciBpdHNlbGYgaW4gdGhlXHJcbiAqIGZ1dHVyZS4gKGUuZy4gY29uZmlybWF0aW9uIGJ1dHRvbnMpLlxyXG4gKiBAZG9jcy1wcml2YXRlXHJcbiAqL1xyXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBNYXREYXRldGltZXBpY2tlckNvbnRlbnQ8RD4gaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0IHtcclxuICAgIGRhdGV0aW1lcGlja2VyOiBNYXREYXRldGltZXBpY2tlcjxEPjtcclxuICAgIF9jYWxlbmRhcjogTWF0RGF0ZXRpbWVwaWNrZXJDYWxlbmRhcjxEPjtcclxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGVzIGtleWRvd24gZXZlbnQgb24gZGF0ZXBpY2tlciBjb250ZW50LlxyXG4gICAgICogQHBhcmFtIGV2ZW50IFRoZSBldmVudC5cclxuICAgICAqL1xyXG4gICAgX2hhbmRsZUtleWRvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkO1xyXG59XHJcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIE1hdERhdGV0aW1lcGlja2VyPEQ+IGltcGxlbWVudHMgT25EZXN0cm95IHtcclxuICAgIHByaXZhdGUgX2RpYWxvZztcclxuICAgIHByaXZhdGUgX292ZXJsYXk7XHJcbiAgICBwcml2YXRlIF9uZ1pvbmU7XHJcbiAgICBwcml2YXRlIF92aWV3Q29udGFpbmVyUmVmO1xyXG4gICAgcHJpdmF0ZSBfc2Nyb2xsU3RyYXRlZ3k7XHJcbiAgICBwcml2YXRlIF9kYXRlQWRhcHRlcjtcclxuICAgIHByaXZhdGUgX2RpcjtcclxuICAgIHByaXZhdGUgX2RvY3VtZW50O1xyXG4gICAgLyoqIEFjdGl2ZSBtdWx0aSB5ZWFyIHZpZXcgd2hlbiBjbGljayBvbiB5ZWFyLiAqL1xyXG4gICAgbXVsdGlZZWFyU2VsZWN0b3I6IGJvb2xlYW47XHJcbiAgICAvKiogaWYgdHJ1ZSBjaGFuZ2UgdGhlIGNsb2NrIHRvIDEyIGhvdXIgZm9ybWF0LiAqL1xyXG4gICAgdHdlbHZlaG91cjogYm9vbGVhbjtcclxuICAgIC8qKiBUaGUgdmlldyB0aGF0IHRoZSBjYWxlbmRhciBzaG91bGQgc3RhcnQgaW4uICovXHJcbiAgICBzdGFydFZpZXc6IE1hdENhbGVuZGFyVmlldztcclxuICAgIG1vZGU6IE1hdERhdGV0aW1lcGlja2VyTW9kZTtcclxuICAgIHRpbWVJbnRlcnZhbDogbnVtYmVyO1xyXG4gICAgYXJpYU5leHRNb250aExhYmVsOiBzdHJpbmc7XHJcbiAgICBhcmlhUHJldk1vbnRoTGFiZWw6IHN0cmluZztcclxuICAgIGFyaWFOZXh0WWVhckxhYmVsOiBzdHJpbmc7XHJcbiAgICBhcmlhUHJldlllYXJMYWJlbDogc3RyaW5nO1xyXG4gICAgLyoqXHJcbiAgICAgKiBFbWl0cyBuZXcgc2VsZWN0ZWQgZGF0ZSB3aGVuIHNlbGVjdGVkIGRhdGUgY2hhbmdlcy5cclxuICAgICAqIEBkZXByZWNhdGVkIFN3aXRjaCB0byB0aGUgYGRhdGVDaGFuZ2VgIGFuZCBgZGF0ZUlucHV0YCBiaW5kaW5nIG9uIHRoZSBpbnB1dCBlbGVtZW50LlxyXG4gICAgICovXHJcbiAgICBzZWxlY3RlZENoYW5nZWQ6IEV2ZW50RW1pdHRlcjxEPjtcclxuICAgIC8qKiBDbGFzc2VzIHRvIGJlIHBhc3NlZCB0byB0aGUgZGF0ZSBwaWNrZXIgcGFuZWwuIFN1cHBvcnRzIHRoZSBzYW1lIHN5bnRheCBhcyBgbmdDbGFzc2AuICovXHJcbiAgICBwYW5lbENsYXNzOiBzdHJpbmcgfCBzdHJpbmdbXTtcclxuICAgIC8qKiBFbWl0cyB3aGVuIHRoZSBkYXRlcGlja2VyIGhhcyBiZWVuIG9wZW5lZC4gKi9cclxuICAgIG9wZW5lZFN0cmVhbTogRXZlbnRFbWl0dGVyPHZvaWQ+O1xyXG4gICAgLyoqIEVtaXRzIHdoZW4gdGhlIGRhdGVwaWNrZXIgaGFzIGJlZW4gY2xvc2VkLiAqL1xyXG4gICAgY2xvc2VkU3RyZWFtOiBFdmVudEVtaXR0ZXI8dm9pZD47XHJcbiAgICAvKiogRW1pdHMgd2hlbiB0aGUgdmlldyBoYXMgYmVlbiBjaGFuZ2VkLiAqKi9cclxuICAgIHZpZXdDaGFuZ2VkOiBFdmVudEVtaXR0ZXI8TWF0Q2FsZW5kYXJWaWV3PjtcclxuICAgIC8qKiBXaGV0aGVyIHRoZSBjYWxlbmRhciBpcyBvcGVuLiAqL1xyXG4gICAgb3BlbmVkOiBib29sZWFuO1xyXG4gICAgLyoqIFRoZSBpZCBmb3IgdGhlIGRhdGVwaWNrZXIgY2FsZW5kYXIuICovXHJcbiAgICBpZDogc3RyaW5nO1xyXG4gICAgLyoqIFRoZSBpbnB1dCBlbGVtZW50IHRoaXMgZGF0ZXBpY2tlciBpcyBhc3NvY2lhdGVkIHdpdGguICovXHJcbiAgICBfZGF0ZXBpY2tlcklucHV0OiBNYXREYXRldGltZXBpY2tlcklucHV0PEQ+O1xyXG4gICAgLyoqIEVtaXRzIHdoZW4gdGhlIGRhdGVwaWNrZXIgaXMgZGlzYWJsZWQuICovXHJcbiAgICBfZGlzYWJsZWRDaGFuZ2U6IFN1YmplY3Q8Ym9vbGVhbj47XHJcbiAgICBwcml2YXRlIF92YWxpZFNlbGVjdGVkO1xyXG4gICAgLyoqIEEgcmVmZXJlbmNlIHRvIHRoZSBvdmVybGF5IHdoZW4gdGhlIGNhbGVuZGFyIGlzIG9wZW5lZCBhcyBhIHBvcHVwLiAqL1xyXG4gICAgcHJpdmF0ZSBfcG9wdXBSZWY7XHJcbiAgICAvKiogQSByZWZlcmVuY2UgdG8gdGhlIGRpYWxvZyB3aGVuIHRoZSBjYWxlbmRhciBpcyBvcGVuZWQgYXMgYSBkaWFsb2cuICovXHJcbiAgICBwcml2YXRlIF9kaWFsb2dSZWY7XHJcbiAgICAvKiogQSBwb3J0YWwgY29udGFpbmluZyB0aGUgY2FsZW5kYXIgZm9yIHRoaXMgZGF0ZXBpY2tlci4gKi9cclxuICAgIHByaXZhdGUgX2NhbGVuZGFyUG9ydGFsO1xyXG4gICAgLyoqIFRoZSBlbGVtZW50IHRoYXQgd2FzIGZvY3VzZWQgYmVmb3JlIHRoZSBkYXRlcGlja2VyIHdhcyBvcGVuZWQuICovXHJcbiAgICBwcml2YXRlIF9mb2N1c2VkRWxlbWVudEJlZm9yZU9wZW47XHJcbiAgICBwcml2YXRlIF9pbnB1dFN1YnNjcmlwdGlvbjtcclxuICAgIGNvbnN0cnVjdG9yKF9kaWFsb2c6IE1hdERpYWxvZywgX292ZXJsYXk6IE92ZXJsYXksIF9uZ1pvbmU6IE5nWm9uZSwgX3ZpZXdDb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWYsIF9zY3JvbGxTdHJhdGVneTogYW55LCBfZGF0ZUFkYXB0ZXI6IERhdGV0aW1lQWRhcHRlcjxEPiwgX2RpcjogRGlyZWN0aW9uYWxpdHksIF9kb2N1bWVudDogYW55KTtcclxuICAgIHByaXZhdGUgX3N0YXJ0QXQ7XHJcbiAgICAvKiogVGhlIGRhdGUgdG8gb3BlbiB0aGUgY2FsZW5kYXIgdG8gaW5pdGlhbGx5LiAqL1xyXG4gICAgZ2V0IHN0YXJ0QXQoKTogRCB8IG51bGw7XHJcbiAgICBzZXQgc3RhcnRBdChkYXRlOiBEIHwgbnVsbCk7XHJcbiAgICBwcml2YXRlIF9vcGVuT25Gb2N1cztcclxuICAgIGdldCBvcGVuT25Gb2N1cygpOiBib29sZWFuO1xyXG4gICAgc2V0IG9wZW5PbkZvY3VzKHZhbHVlOiBib29sZWFuKTtcclxuICAgIHByaXZhdGUgX3R5cGU7XHJcbiAgICBnZXQgdHlwZSgpOiBNYXREYXRldGltZXBpY2tlclR5cGU7XHJcbiAgICBzZXQgdHlwZSh2YWx1ZTogTWF0RGF0ZXRpbWVwaWNrZXJUeXBlKTtcclxuICAgIHByaXZhdGUgX3RvdWNoVWk7XHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdGhlIGNhbGVuZGFyIFVJIGlzIGluIHRvdWNoIG1vZGUuIEluIHRvdWNoIG1vZGUgdGhlIGNhbGVuZGFyIG9wZW5zIGluIGEgZGlhbG9nIHJhdGhlclxyXG4gICAgICogdGhhbiBhIHBvcHVwIGFuZCBlbGVtZW50cyBoYXZlIG1vcmUgcGFkZGluZyB0byBhbGxvdyBmb3IgYmlnZ2VyIHRvdWNoIHRhcmdldHMuXHJcbiAgICAgKi9cclxuICAgIGdldCB0b3VjaFVpKCk6IGJvb2xlYW47XHJcbiAgICBzZXQgdG91Y2hVaSh2YWx1ZTogYm9vbGVhbik7XHJcbiAgICBwcml2YXRlIF9kaXNhYmxlZDtcclxuICAgIC8qKiBXaGV0aGVyIHRoZSBkYXRlcGlja2VyIHBvcC11cCBzaG91bGQgYmUgZGlzYWJsZWQuICovXHJcbiAgICBnZXQgZGlzYWJsZWQoKTogYm9vbGVhbjtcclxuICAgIHNldCBkaXNhYmxlZCh2YWx1ZTogYm9vbGVhbik7XHJcbiAgICAvKiogVGhlIGN1cnJlbnRseSBzZWxlY3RlZCBkYXRlLiAqL1xyXG4gICAgZ2V0IF9zZWxlY3RlZCgpOiBEIHwgbnVsbDtcclxuICAgIHNldCBfc2VsZWN0ZWQodmFsdWU6IEQgfCBudWxsKTtcclxuICAgIC8qKiBUaGUgbWluaW11bSBzZWxlY3RhYmxlIGRhdGUuICovXHJcbiAgICBnZXQgX21pbkRhdGUoKTogRCB8IG51bGw7XHJcbiAgICAvKiogVGhlIG1heGltdW0gc2VsZWN0YWJsZSBkYXRlLiAqL1xyXG4gICAgZ2V0IF9tYXhEYXRlKCk6IEQgfCBudWxsO1xyXG4gICAgZ2V0IF9kYXRlRmlsdGVyKCk6IChkYXRlOiBEIHwgbnVsbCwgdHlwZTogTWF0RGF0ZXRpbWVwaWNrZXJGaWx0ZXJUeXBlKSA9PiBib29sZWFuO1xyXG4gICAgX2hhbmRsZUZvY3VzKCk6IHZvaWQ7XHJcbiAgICBfdmlld0NoYW5nZWQodHlwZTogTWF0Q2FsZW5kYXJWaWV3KTogdm9pZDtcclxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQ7XHJcbiAgICAvKiogU2VsZWN0cyB0aGUgZ2l2ZW4gZGF0ZSAqL1xyXG4gICAgX3NlbGVjdChkYXRlOiBEKTogdm9pZDtcclxuICAgIC8qKlxyXG4gICAgICogUmVnaXN0ZXIgYW4gaW5wdXQgd2l0aCB0aGlzIGRhdGVwaWNrZXIuXHJcbiAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIGRhdGVwaWNrZXIgaW5wdXQgdG8gcmVnaXN0ZXIgd2l0aCB0aGlzIGRhdGVwaWNrZXIuXHJcbiAgICAgKi9cclxuICAgIF9yZWdpc3RlcklucHV0KGlucHV0OiBNYXREYXRldGltZXBpY2tlcklucHV0PEQ+KTogdm9pZDtcclxuICAgIC8qKiBPcGVuIHRoZSBjYWxlbmRhci4gKi9cclxuICAgIG9wZW4oKTogdm9pZDtcclxuICAgIC8qKiBDbG9zZSB0aGUgY2FsZW5kYXIuICovXHJcbiAgICBjbG9zZSgpOiB2b2lkO1xyXG4gICAgLyoqIE9wZW4gdGhlIGNhbGVuZGFyIGFzIGEgZGlhbG9nLiAqL1xyXG4gICAgcHJpdmF0ZSBfb3BlbkFzRGlhbG9nO1xyXG4gICAgLyoqIE9wZW4gdGhlIGNhbGVuZGFyIGFzIGEgcG9wdXAuICovXHJcbiAgICBwcml2YXRlIF9vcGVuQXNQb3B1cDtcclxuICAgIC8qKiBDcmVhdGUgdGhlIHBvcHVwLiAqL1xyXG4gICAgcHJpdmF0ZSBfY3JlYXRlUG9wdXA7XHJcbiAgICAvKiogQ3JlYXRlIHRoZSBwb3B1cCBQb3NpdGlvblN0cmF0ZWd5LiAqL1xyXG4gICAgcHJpdmF0ZSBfY3JlYXRlUG9wdXBQb3NpdGlvblN0cmF0ZWd5O1xyXG59XHJcbiJdfQ==