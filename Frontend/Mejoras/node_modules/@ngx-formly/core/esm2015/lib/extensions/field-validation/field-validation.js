/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Validators } from '@angular/forms';
import { FORMLY_VALIDATORS, defineHiddenProp, isPromise, wrapProperty, clone } from '../../utils';
import { updateValidity } from '../field-form/utils';
/**
 * \@experimental
 */
export class FieldValidationExtension {
    /**
     * @param {?} formlyConfig
     */
    constructor(formlyConfig) {
        this.formlyConfig = formlyConfig;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    onPopulate(field) {
        this.initFieldValidation(field, 'validators');
        this.initFieldValidation(field, 'asyncValidators');
    }
    /**
     * @private
     * @param {?} field
     * @param {?} type
     * @return {?}
     */
    initFieldValidation(field, type) {
        /** @type {?} */
        const validators = [];
        if (type === 'validators' && !(field.hasOwnProperty('fieldGroup') && !field.key)) {
            validators.push(this.getPredefinedFieldValidation(field));
        }
        if (field[type]) {
            for (const validatorName in field[type]) {
                if (validatorName === 'validation' && !Array.isArray(field[type].validation)) {
                    field[type].validation = [field[type].validation];
                    console.warn(`NgxFormly(${field.key}): passing a non array value to the 'validation' is deprecated, pass an array instead`);
                }
                validatorName === 'validation'
                    ? validators.push(...field[type].validation.map((/**
                     * @param {?} v
                     * @return {?}
                     */
                    v => this.wrapNgValidatorFn(field, v))))
                    : validators.push(this.wrapNgValidatorFn(field, field[type][validatorName], validatorName));
            }
        }
        defineHiddenProp(field, '_' + type, validators);
    }
    /**
     * @private
     * @param {?} field
     * @return {?}
     */
    getPredefinedFieldValidation(field) {
        /** @type {?} */
        let VALIDATORS = [];
        FORMLY_VALIDATORS.forEach((/**
         * @param {?} opt
         * @return {?}
         */
        opt => wrapProperty(field.templateOptions, opt, (/**
         * @param {?} __0
         * @return {?}
         */
        ({ currentValue, firstChange }) => {
            VALIDATORS = VALIDATORS.filter((/**
             * @param {?} o
             * @return {?}
             */
            o => o !== opt));
            if (currentValue != null && currentValue !== false) {
                VALIDATORS.push(opt);
            }
            if (!firstChange && field.formControl) {
                updateValidity(field.formControl);
            }
        }))));
        return (/**
         * @param {?} control
         * @return {?}
         */
        (control) => {
            if (VALIDATORS.length === 0) {
                return null;
            }
            return Validators.compose(VALIDATORS.map((/**
             * @param {?} opt
             * @return {?}
             */
            opt => (/**
             * @return {?}
             */
            () => {
                /** @type {?} */
                const value = field.templateOptions[opt];
                switch (opt) {
                    case 'required':
                        return Validators.required(control);
                    case 'pattern':
                        return Validators.pattern(value)(control);
                    case 'minLength':
                        return Validators.minLength(value)(control);
                    case 'maxLength':
                        return Validators.maxLength(value)(control);
                    case 'min':
                        return Validators.min(value)(control);
                    case 'max':
                        return Validators.max(value)(control);
                }
            }))))(control);
        });
    }
    /**
     * @private
     * @param {?} field
     * @param {?} validator
     * @param {?=} validatorName
     * @return {?}
     */
    wrapNgValidatorFn(field, validator, validatorName) {
        /** @type {?} */
        let validatorOption = null;
        if (typeof validator === 'string') {
            validatorOption = clone(this.formlyConfig.getValidator(validator));
        }
        if (typeof validator === 'object' && validator.name) {
            validatorOption = clone(this.formlyConfig.getValidator(validator.name));
            if (validator.options) {
                validatorOption.options = validator.options;
            }
        }
        if (typeof validator === 'object' && validator.expression) {
            const { expression } = validator, options = tslib_1.__rest(validator, ["expression"]);
            validatorOption = {
                name: validatorName,
                validation: expression,
                options: Object.keys(options).length > 0 ? options : null,
            };
        }
        if (typeof validator === 'function') {
            validatorOption = {
                name: validatorName,
                validation: validator,
            };
        }
        return (/**
         * @param {?} control
         * @return {?}
         */
        (control) => {
            /** @type {?} */
            let errors = validatorOption.validation(control, field, validatorOption.options);
            if (validatorName) {
                if (isPromise(errors)) {
                    return errors.then((/**
                     * @param {?} result
                     * @return {?}
                     */
                    (result) => {
                        // workaround for https://github.com/angular/angular/issues/13200
                        if (field.options && field.options._markForCheck) {
                            field.options._markForCheck(field);
                        }
                        return this.handleResult(field, !!result, validatorOption);
                    }));
                }
                errors = !!errors;
            }
            return this.handleResult(field, errors, validatorOption);
        });
    }
    /**
     * @private
     * @param {?} field
     * @param {?} errors
     * @param {?} __2
     * @return {?}
     */
    handleResult(field, errors, { name, options }) {
        if (typeof errors === 'boolean') {
            errors = errors ? null : { [name]: options ? options : true };
        }
        /** @type {?} */
        const ctrl = field.formControl;
        ctrl['_childrenErrors'] && ctrl['_childrenErrors'][name] && ctrl['_childrenErrors'][name]();
        if (errors && errors[name]) {
            /** @type {?} */
            const errorPath = errors[name].errorPath
                ? errors[name].errorPath
                : (options || {}).errorPath;
            /** @type {?} */
            const childCtrl = errorPath ? field.formControl.get(errorPath) : null;
            if (childCtrl) {
                const _a = errors[name], { errorPath } = _a, opts = tslib_1.__rest(_a, ["errorPath"]);
                childCtrl.setErrors(Object.assign({}, (childCtrl.errors || {}), { [name]: opts }));
                !ctrl['_childrenErrors'] && defineHiddenProp(ctrl, '_childrenErrors', {});
                ctrl['_childrenErrors'][name] = (/**
                 * @return {?}
                 */
                () => {
                    const _a = childCtrl.errors || {}, _b = name, toDelete = _a[_b], childErrors = tslib_1.__rest(_a, [typeof _b === "symbol" ? _b : _b + ""]);
                    childCtrl.setErrors(Object.keys(childErrors).length === 0 ? null : childErrors);
                });
            }
        }
        return errors;
    }
}
if (false) {
    /**
     * @type {?}
     * @private
     */
    FieldValidationExtension.prototype.formlyConfig;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmllbGQtdmFsaWRhdGlvbi5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BuZ3gtZm9ybWx5L2NvcmUvIiwic291cmNlcyI6WyJsaWIvZXh0ZW5zaW9ucy9maWVsZC12YWxpZGF0aW9uL2ZpZWxkLXZhbGlkYXRpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFFQSxPQUFPLEVBQW1CLFVBQVUsRUFBZSxNQUFNLGdCQUFnQixDQUFDO0FBQzFFLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxnQkFBZ0IsRUFBRSxTQUFTLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUNsRyxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0scUJBQXFCLENBQUM7Ozs7QUFHckQsTUFBTSxPQUFPLHdCQUF3Qjs7OztJQUNuQyxZQUFvQixZQUEwQjtRQUExQixpQkFBWSxHQUFaLFlBQVksQ0FBYztJQUFHLENBQUM7Ozs7O0lBRWxELFVBQVUsQ0FBQyxLQUE2QjtRQUN0QyxJQUFJLENBQUMsbUJBQW1CLENBQUMsS0FBSyxFQUFFLFlBQVksQ0FBQyxDQUFDO1FBQzlDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxLQUFLLEVBQUUsaUJBQWlCLENBQUMsQ0FBQztJQUNyRCxDQUFDOzs7Ozs7O0lBRU8sbUJBQW1CLENBQUMsS0FBNkIsRUFBRSxJQUFzQzs7Y0FDekYsVUFBVSxHQUFrQixFQUFFO1FBQ3BDLElBQUksSUFBSSxLQUFLLFlBQVksSUFBSSxDQUFDLENBQUMsS0FBSyxDQUFDLGNBQWMsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUNoRixVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyw0QkFBNEIsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1NBQzNEO1FBRUQsSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDZixLQUFLLE1BQU0sYUFBYSxJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFB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LENBQUMsV0FBVyxDQUFDLENBQUM7Z0JBQ2xGLENBQUMsQ0FBQSxDQUFDO2FBQ0g7U0FDRjtRQUVELE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7Q0FDRjs7Ozs7O0lBaEphLGdEQUFrQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEZvcm1seUV4dGVuc2lvbiwgRm9ybWx5Q29uZmlnLCBWYWxpZGF0b3JPcHRpb24gfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9mb3JtbHkuY29uZmlnJztcbmltcG9ydCB7IEZvcm1seUZpZWxkQ29uZmlnQ2FjaGUgfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL2Zvcm1seS5maWVsZC5jb25maWcnO1xuaW1wb3J0IHsgQWJzdHJhY3RDb250cm9sLCBWYWxpZGF0b3JzLCBWYWxpZGF0b3JGbiB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IEZPUk1MWV9WQUxJREFUT1JTLCBkZWZpbmVIaWRkZW5Qcm9wLCBpc1Byb21pc2UsIHdyYXBQcm9wZXJ0eSwgY2xvbmUgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgeyB1cGRhdGVWYWxpZGl0eSB9IGZyb20gJy4uL2ZpZWxkLWZvcm0vdXRpbHMnO1xuXG4vKiogQGV4cGVyaW1lbnRhbCAqL1xuZXhwb3J0IGNsYXNzIEZpZWxkVmFsaWRhdGlvbkV4dGVuc2lvbiBpbXBsZW1lbnRzIEZvcm1seUV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgZm9ybWx5Q29uZmlnOiBGb3JtbHlDb25maWcpIHt9XG5cbiAgb25Qb3B1bGF0ZShmaWVsZDogRm9ybWx5RmllbGRDb25maWdDYWNoZSkge1xuICAgIHRoaXMuaW5pdEZpZWxkVmFsaWRhdGlvbihmaWVsZCwgJ3ZhbGlkYXRvcnMnKTtcbiAgICB0aGlzLmluaXRGaWVsZFZhbGlkYXRpb24oZmllbGQsICdhc3luY1ZhbGlkYXRvcnMnKTtcbiAgfVxuXG4gIHByaXZhdGUgaW5pdEZpZWxkVmFsaWRhdGlvbihmaWVsZDogRm9ybWx5RmllbGRDb25maWdDYWNoZSwgdHlwZTogJ3ZhbGlkYXRvcnMnIHwgJ2FzeW5jVmFsaWRhdG9ycycpIHtcbiAgICBjb25zdCB2YWxpZGF0b3JzOiBWYWxpZGF0b3JGbltdID0gW107XG4gICAgaWYgKHR5cGUgPT09ICd2YWxpZGF0b3JzJyAmJiAhKGZpZWxkLmhhc093blByb3BlcnR5KCdmaWVsZEdyb3VwJykgJiYgIWZpZWxkLmtleSkpIHtcbiAgICAgIHZhbGlkYXRvcnMucHVzaCh0aGlzLmdldFByZWRlZmluZWRGaWVsZFZhbGlkYXRpb24oZmllbGQpKTtcbiAgICB9XG5cbiAgICBpZiAoZmllbGRbdHlwZV0pIHtcbiAgICAgIGZvciAoY29uc3QgdmFsaWRhdG9yTmFtZSBpbiBmaWVsZFt0eXBlXSkge1xuICAgICAgICBpZiAodmFsaWRhdG9yTmFtZSA9PT0gJ3ZhbGlkYXRpb24nICYmICFBcnJheS5pc0FycmF5KGZpZWxkW3R5cGVdLnZhbGlkYXRpb24pKSB7XG4gICAgICAgICAgZmllbGRbdHlwZV0udmFsaWRhdGlvbiA9IFtmaWVsZFt0eXBlXS52YWxpZGF0aW9uXTtcbiAgICAgICAgICBjb25zb2xlLndhcm4oYE5neEZvcm1seSgke2ZpZWxkLmtleX0pOiBwYXNzaW5nIGEgbm9uIGFycmF5IHZhbHVlIHRvIHRoZSAndmFsaWRhdGlvbicgaXMgZGVwcmVjYXRlZCwgcGFzcyBhbiBhcnJheSBpbnN0ZWFkYCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YWxpZGF0b3JOYW1lID09PSAndmFsaWRhdGlvbidcbiAgICAgICAgICA/IHZhbGlkYXRvcnMucHVzaCguLi5maWVsZFt0eXBlXS52YWxpZGF0aW9uLm1hcCh2ID0+IHRoaXMud3JhcE5nVmFsaWRhdG9yRm4oZmllbGQsIHYpKSlcbiAgICAgICAgICA6IHZhbGlkYXRvcnMucHVzaCh0aGlzLndyYXBOZ1ZhbGlkYXRvckZuKGZpZWxkLCBmaWVsZFt0eXBlXVt2YWxpZGF0b3JOYW1lXSwgdmFsaWRhdG9yTmFtZSkpXG4gICAgICAgIDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkZWZpbmVIaWRkZW5Qcm9wKGZpZWxkLCAnXycgKyB0eXBlLCB2YWxpZGF0b3JzKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0UHJlZGVmaW5lZEZpZWxkVmFsaWRhdGlvbihmaWVsZDogRm9ybWx5RmllbGRDb25maWdDYWNoZSk6IFZhbGlkYXRvckZuIHtcbiAgICBsZXQgVkFMSURBVE9SUyA9IFtdO1xuICAgIEZPUk1MWV9WQUxJREFUT1JTLmZvckVhY2gob3B0ID0+IHdyYXBQcm9wZXJ0eShmaWVsZC50ZW1wbGF0ZU9wdGlvbnMsIG9wdCwgKHsgY3VycmVudFZhbHVlLCBmaXJzdENoYW5nZSB9KSA9PiB7XG4gICAgICBWQUxJREFUT1JTID0gVkFMSURBVE9SUy5maWx0ZXIobyA9PiBvICE9PSBvcHQpO1xuICAgICAgaWYgKGN1cnJlbnRWYWx1ZSAhPSBudWxsICYmIGN1cnJlbnRWYWx1ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgVkFMSURBVE9SUy5wdXNoKG9wdCk7XG4gICAgICB9XG4gICAgICBpZiAoIWZpcnN0Q2hhbmdlICYmIGZpZWxkLmZvcm1Db250cm9sKSB7XG4gICAgICAgIHVwZGF0ZVZhbGlkaXR5KGZpZWxkLmZvcm1Db250cm9sKTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICByZXR1cm4gKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCkgPT4ge1xuICAgICAgaWYgKFZBTElEQVRPUlMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gVmFsaWRhdG9ycy5jb21wb3NlKFZBTElEQVRPUlMubWFwKG9wdCA9PiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZmllbGQudGVtcGxhdGVPcHRpb25zW29wdF07XG4gICAgICAgIHN3aXRjaCAob3B0KSB7XG4gICAgICAgICAgY2FzZSAncmVxdWlyZWQnOlxuICAgICAgICAgICAgcmV0dXJuIFZhbGlkYXRvcnMucmVxdWlyZWQoY29udHJvbCk7XG4gICAgICAgICAgY2FzZSAncGF0dGVybic6XG4gICAgICAgICAgICByZXR1cm4gVmFsaWRhdG9ycy5wYXR0ZXJuKHZhbHVlKShjb250cm9sKTtcbiAgICAgICAgICBjYXNlICdtaW5MZW5ndGgnOlxuICAgICAgICAgICAgcmV0dXJuIFZhbGlkYXRvcnMubWluTGVuZ3RoKHZhbHVlKShjb250cm9sKTtcbiAgICAgICAgICBjYXNlICdtYXhMZW5ndGgnOlxuICAgICAgICAgICAgcmV0dXJuIFZhbGlkYXRvcnMubWF4TGVuZ3RoKHZhbHVlKShjb250cm9sKTtcbiAgICAgICAgICBjYXNlICdtaW4nOlxuICAgICAgICAgICAgcmV0dXJuIFZhbGlkYXRvcnMubWluKHZhbHVlKShjb250cm9sKTtcbiAgICAgICAgICBjYXNlICdtYXgnOlxuICAgICAgICAgICAgcmV0dXJuIFZhbGlkYXRvcnMubWF4KHZhbHVlKShjb250cm9sKTtcbiAgICAgICAgfVxuICAgICAgfSkpKGNvbnRyb2wpO1xuICAgIH07XG4gIH1cblxuICBwcml2YXRlIHdyYXBOZ1ZhbGlkYXRvckZuKGZpZWxkOiBGb3JtbHlGaWVsZENvbmZpZ0NhY2hlLCB2YWxpZGF0b3I6IGFueSwgdmFsaWRhdG9yTmFtZT86IHN0cmluZykge1xuICAgIGxldCB2YWxpZGF0b3JPcHRpb246IFZhbGlkYXRvck9wdGlvbiA9IG51bGw7XG4gICAgaWYgKHR5cGVvZiB2YWxpZGF0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWxpZGF0b3JPcHRpb24gPSBjbG9uZSh0aGlzLmZvcm1seUNvbmZpZy5nZXRWYWxpZGF0b3IodmFsaWRhdG9yKSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWxpZGF0b3IgPT09ICdvYmplY3QnICYmIHZhbGlkYXRvci5uYW1lKSB7XG4gICAgICB2YWxpZGF0b3JPcHRpb24gPSBjbG9uZSh0aGlzLmZvcm1seUNvbmZpZy5nZXRWYWxpZGF0b3IodmFsaWRhdG9yLm5hbWUpKTtcbiAgICAgIGlmICh2YWxpZGF0b3Iub3B0aW9ucykge1xuICAgICAgICB2YWxpZGF0b3JPcHRpb24ub3B0aW9ucyA9IHZhbGlkYXRvci5vcHRpb25zO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsaWRhdG9yID09PSAnb2JqZWN0JyAmJiB2YWxpZGF0b3IuZXhwcmVzc2lvbikge1xuICAgICAgY29uc3QgeyBleHByZXNzaW9uLCAuLi5vcHRpb25zIH0gPSB2YWxpZGF0b3I7XG4gICAgICB2YWxpZGF0b3JPcHRpb24gPSB7XG4gICAgICAgIG5hbWU6IHZhbGlkYXRvck5hbWUsXG4gICAgICAgIHZhbGlkYXRpb246IGV4cHJlc3Npb24sXG4gICAgICAgIG9wdGlvbnM6IE9iamVjdC5rZXlzKG9wdGlvbnMpLmxlbmd0aCA+IDAgPyBvcHRpb25zIDogbnVsbCxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWxpZGF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhbGlkYXRvck9wdGlvbiA9IHtcbiAgICAgICAgbmFtZTogdmFsaWRhdG9yTmFtZSxcbiAgICAgICAgdmFsaWRhdGlvbjogdmFsaWRhdG9yLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCkgPT4ge1xuICAgICAgbGV0IGVycm9yczogYW55ID0gdmFsaWRhdG9yT3B0aW9uLnZhbGlkYXRpb24oY29udHJvbCwgZmllbGQsIHZhbGlkYXRvck9wdGlvbi5vcHRpb25zKTtcbiAgICAgIGlmICh2YWxpZGF0b3JOYW1lKSB7XG4gICAgICAgIGlmIChpc1Byb21pc2UoZXJyb3JzKSkge1xuICAgICAgICAgIHJldHVybiBlcnJvcnMudGhlbigocmVzdWx0OiBib29sZWFuKSA9PiB7XG4gICAgICAgICAgICAvLyB3b3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8xMzIwMFxuICAgICAgICAgICAgaWYgKGZpZWxkLm9wdGlvbnMgJiYgZmllbGQub3B0aW9ucy5fbWFya0ZvckNoZWNrKSB7XG4gICAgICAgICAgICAgIGZpZWxkLm9wdGlvbnMuX21hcmtGb3JDaGVjayhmaWVsZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVJlc3VsdChmaWVsZCwgISFyZXN1bHQsIHZhbGlkYXRvck9wdGlvbik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3JzID0gISFlcnJvcnM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVJlc3VsdChmaWVsZCwgZXJyb3JzLCB2YWxpZGF0b3JPcHRpb24pO1xuICAgIH07XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZVJlc3VsdChmaWVsZDogRm9ybWx5RmllbGRDb25maWdDYWNoZSwgZXJyb3JzOiBhbnksIHsgbmFtZSwgb3B0aW9ucyB9OiBWYWxpZGF0b3JPcHRpb24pIHtcbiAgICBpZiAodHlwZW9mIGVycm9ycyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICBlcnJvcnMgPSBlcnJvcnMgPyBudWxsIDogeyBbbmFtZV06IG9wdGlvbnMgPyBvcHRpb25zIDogdHJ1ZSB9O1xuICAgIH1cblxuICAgIGNvbnN0IGN0cmwgPSBmaWVsZC5mb3JtQ29udHJvbDtcbiAgICBjdHJsWydfY2hpbGRyZW5FcnJvcnMnXSAmJiBjdHJsWydfY2hpbGRyZW5FcnJvcnMnXVtuYW1lXSAmJiBjdHJsWydfY2hpbGRyZW5FcnJvcnMnXVtuYW1lXSgpO1xuXG4gICAgaWYgKGVycm9ycyAmJiBlcnJvcnNbbmFtZV0pIHtcbiAgICAgIGNvbnN0IGVycm9yUGF0aCA9IGVycm9yc1tuYW1lXS5lcnJvclBhdGhcbiAgICAgICAgPyBlcnJvcnNbbmFtZV0uZXJyb3JQYXRoXG4gICAgICAgIDogKG9wdGlvbnMgfHwge30pLmVycm9yUGF0aDtcblxuICAgICAgY29uc3QgY2hpbGRDdHJsID0gZXJyb3JQYXRoID8gZmllbGQuZm9ybUNvbnRyb2wuZ2V0KGVycm9yUGF0aCkgOiBudWxsO1xuICAgICAgaWYgKGNoaWxkQ3RybCkge1xuICAgICAgICBjb25zdCB7IGVycm9yUGF0aCwgLi4ub3B0cyB9ID0gZXJyb3JzW25hbWVdO1xuICAgICAgICBjaGlsZEN0cmwuc2V0RXJyb3JzKHsgLi4uKGNoaWxkQ3RybC5lcnJvcnMgfHwge30pLCBbbmFtZV06IG9wdHMgfSk7XG5cbiAgICAgICAgIWN0cmxbJ19jaGlsZHJlbkVycm9ycyddICYmIGRlZmluZUhpZGRlblByb3AoY3RybCwgJ19jaGlsZHJlbkVycm9ycycsIHt9KTtcbiAgICAgICAgY3RybFsnX2NoaWxkcmVuRXJyb3JzJ11bbmFtZV0gPSAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBbbmFtZV06IHRvRGVsZXRlLCAuLi5jaGlsZEVycm9ycyB9ID0gY2hpbGRDdHJsLmVycm9ycyB8fCB7fTtcbiAgICAgICAgICBjaGlsZEN0cmwuc2V0RXJyb3JzKE9iamVjdC5rZXlzKGNoaWxkRXJyb3JzKS5sZW5ndGggPT09IDAgPyBudWxsIDogY2hpbGRFcnJvcnMpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlcnJvcnM7XG4gIH1cbn1cbiJdfQ==