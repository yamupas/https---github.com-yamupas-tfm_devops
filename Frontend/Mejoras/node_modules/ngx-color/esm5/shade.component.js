import { __decorate } from "tslib";
import { CommonModule } from '@angular/common';
import { ChangeDetectionStrategy, Component, EventEmitter, Input, NgModule, Output, } from '@angular/core';
import { CoordinatesModule } from './coordinates.directive';
import { TinyColor } from '@ctrl/tinycolor';
var ShadeComponent = /** @class */ (function () {
    function ShadeComponent() {
        this.onChange = new EventEmitter();
    }
    ShadeComponent.prototype.ngOnChanges = function () {
        this.gradient = {
            background: "linear-gradient(to right,\n          hsl(" + this.hsl.h + ", 90%, 55%),\n          #000)",
        };
        var hsv = new TinyColor(this.hsl).toHsv();
        this.pointerLeft = 100 - (hsv.v * 100);
    };
    ShadeComponent.prototype.handleChange = function (_a) {
        var left = _a.left, containerWidth = _a.containerWidth, $event = _a.$event;
        var data;
        var v;
        if (left < 0) {
            v = 0;
        }
        else if (left > containerWidth) {
            v = 1;
        }
        else {
            v = Math.round((left * 100) / containerWidth) / 100;
        }
        var hsv = new TinyColor(this.hsl).toHsv();
        if (hsv.v !== v) {
            data = {
                h: this.hsl.h,
                s: 100,
                v: 1 - v,
                l: this.hsl.l,
                a: this.hsl.a,
                source: 'rgb',
            };
        }
        if (!data) {
            return null;
        }
        this.onChange.emit({ data: data, $event: $event });
    };
    __decorate([
        Input()
    ], ShadeComponent.prototype, "hsl", void 0);
    __decorate([
        Input()
    ], ShadeComponent.prototype, "rgb", void 0);
    __decorate([
        Input()
    ], ShadeComponent.prototype, "pointer", void 0);
    __decorate([
        Input()
    ], ShadeComponent.prototype, "shadow", void 0);
    __decorate([
        Input()
    ], ShadeComponent.prototype, "radius", void 0);
    __decorate([
        Output()
    ], ShadeComponent.prototype, "onChange", void 0);
    ShadeComponent = __decorate([
        Component({
            selector: 'color-shade',
            template: "\n    <div class=\"shade\" [style.border-radius]=\"radius\">\n      <div\n        class=\"shade-gradient\"\n        [ngStyle]=\"gradient\"\n        [style.box-shadow]=\"shadow\"\n        [style.border-radius]=\"radius\"\n      ></div>\n      <div\n        ngx-color-coordinates\n        (coordinatesChange)=\"handleChange($event)\"\n        class=\"shade-container\"\n      >\n        <div\n          class=\"shade-pointer\"\n          [style.left.%]=\"pointerLeft\"\n          [style.top.%]=\"pointerTop\"\n        >\n          <div class=\"shade-slider\" [ngStyle]=\"pointer\"></div>\n        </div>\n      </div>\n    </div>\n  ",
            changeDetection: ChangeDetectionStrategy.OnPush,
            preserveWhitespaces: false,
            styles: ["\n    .shade {\n      position: absolute;\n      top: 0;\n      bottom: 0;\n      left: 0;\n      right: 0;\n    }\n    .shade-gradient {\n      position: absolute;\n      top: 0;\n      bottom: 0;\n      left: 0;\n      right: 0;\n    }\n    .shade-container {\n      position: relative;\n      height: 100%;\n      margin: 0 3px;\n    }\n    .shade-pointer {\n      position: absolute;\n    }\n    .shade-slider {\n      width: 4px;\n      border-radius: 1px;\n      height: 8px;\n      box-shadow: 0 0 2px rgba(0, 0, 0, .6);\n      background: #fff;\n      margin-top: 1px;\n      transform: translateX(-2px);\n    },\n  "]
        })
    ], ShadeComponent);
    return ShadeComponent;
}());
export { ShadeComponent };
var ShadeModule = /** @class */ (function () {
    function ShadeModule() {
    }
    ShadeModule = __decorate([
        NgModule({
            declarations: [ShadeComponent],
            exports: [ShadeComponent],
            imports: [CommonModule, CoordinatesModule],
        })
    ], ShadeModule);
    return ShadeModule;
}());
export { ShadeModule };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2hhZGUuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LWNvbG9yLyIsInNvdXJjZXMiOlsic2hhZGUuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDL0MsT0FBTyxFQUNMLHVCQUF1QixFQUN2QixTQUFTLEVBQ1QsWUFBWSxFQUNaLEtBQUssRUFDTCxRQUFRLEVBRVIsTUFBTSxHQUNQLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBRTVELE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQWtFNUM7SUFBQTtRQU1ZLGFBQVEsR0FBRyxJQUFJLFlBQVksRUFBTyxDQUFDO0lBNEMvQyxDQUFDO0lBdkNDLG9DQUFXLEdBQVg7UUFDRSxJQUFJLENBQUMsUUFBUSxHQUFHO1lBQ2QsVUFBVSxFQUFFLDhDQUNGLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxrQ0FDVjtTQUNYLENBQUM7UUFDRixJQUFNLEdBQUcsR0FBRyxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDNUMsSUFBSSxDQUFDLFdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDO0lBQ3pDLENBQUM7SUFFRCxxQ0FBWSxHQUFaLFVBQWEsRUFBZ0M7WUFBOUIsY0FBSSxFQUFFLGtDQUFjLEVBQUUsa0JBQU07UUFDekMsSUFBSSxJQUFJLENBQUM7UUFDVCxJQUFJLENBQVMsQ0FBQztRQUNkLElBQUksSUFBSSxHQUFHLENBQUMsRUFBRTtZQUNaLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDUDthQUFNLElBQUksSUFBSSxHQUFHLGNBQWMsRUFBRTtZQUNoQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ1A7YUFBTTtZQUNMLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxHQUFHLEdBQUcsQ0FBQyxHQUFHLGNBQWMsQ0FBQyxHQUFHLEdBQUcsQ0FBQztTQUNyRDtRQUVELElBQU0sR0FBRyxHQUFHLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUM1QyxJQUFJLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ2YsSUFBSSxHQUFHO2dCQUNMLENBQUMsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBQ2IsQ0FBQyxFQUFFLEdBQUc7Z0JBQ04sQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDO2dCQUNSLENBQUMsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBQ2IsQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztnQkFDYixNQUFNLEVBQUUsS0FBSzthQUNkLENBQUM7U0FDSDtRQUVELElBQUksQ0FBQyxJQUFJLEVBQUU7WUFDVCxPQUFPLElBQUksQ0FBQztTQUNiO1FBRUQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRSxJQUFJLE1BQUEsRUFBRSxNQUFNLFFBQUEsRUFBRSxDQUFDLENBQUM7SUFDdkMsQ0FBQztJQWhEUTtRQUFSLEtBQUssRUFBRTsrQ0FBVztJQUNWO1FBQVIsS0FBSyxFQUFFOytDQUFXO0lBQ1Y7UUFBUixLQUFLLEVBQUU7bURBQW9DO0lBQ25DO1FBQVIsS0FBSyxFQUFFO2tEQUFnQjtJQUNmO1FBQVIsS0FBSyxFQUFFO2tEQUFnQjtJQUNkO1FBQVQsTUFBTSxFQUFFO29EQUFvQztJQU5sQyxjQUFjO1FBL0QxQixTQUFTLENBQUM7WUFDVCxRQUFRLEVBQUUsYUFBYTtZQUN2QixRQUFRLEVBQUUseW5CQXNCVDtZQW9DRCxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTtZQUMvQyxtQkFBbUIsRUFBRSxLQUFLO3FCQW5DeEIsa25CQWdDRDtTQUlGLENBQUM7T0FDVyxjQUFjLENBa0QxQjtJQUFELHFCQUFDO0NBQUEsQUFsREQsSUFrREM7U0FsRFksY0FBYztBQXlEM0I7SUFBQTtJQUEwQixDQUFDO0lBQWQsV0FBVztRQUx2QixRQUFRLENBQUM7WUFDUixZQUFZLEVBQUUsQ0FBQyxjQUFjLENBQUM7WUFDOUIsT0FBTyxFQUFFLENBQUMsY0FBYyxDQUFDO1lBQ3pCLE9BQU8sRUFBRSxDQUFDLFlBQVksRUFBRSxpQkFBaUIsQ0FBQztTQUMzQyxDQUFDO09BQ1csV0FBVyxDQUFHO0lBQUQsa0JBQUM7Q0FBQSxBQUEzQixJQUEyQjtTQUFkLFdBQVciLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENvbXBvbmVudCxcbiAgRXZlbnRFbWl0dGVyLFxuICBJbnB1dCxcbiAgTmdNb2R1bGUsXG4gIE9uQ2hhbmdlcyxcbiAgT3V0cHV0LFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvb3JkaW5hdGVzTW9kdWxlIH0gZnJvbSAnLi9jb29yZGluYXRlcy5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgSFNMQSwgUkdCQSB9IGZyb20gJy4vaGVscGVycy9jb2xvci5pbnRlcmZhY2VzJztcbmltcG9ydCB7IFRpbnlDb2xvciB9IGZyb20gJ0BjdHJsL3Rpbnljb2xvcic7XG5cblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY29sb3Itc2hhZGUnLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxkaXYgY2xhc3M9XCJzaGFkZVwiIFtzdHlsZS5ib3JkZXItcmFkaXVzXT1cInJhZGl1c1wiPlxuICAgICAgPGRpdlxuICAgICAgICBjbGFzcz1cInNoYWRlLWdyYWRpZW50XCJcbiAgICAgICAgW25nU3R5bGVdPVwiZ3JhZGllbnRcIlxuICAgICAgICBbc3R5bGUuYm94LXNoYWRvd109XCJzaGFkb3dcIlxuICAgICAgICBbc3R5bGUuYm9yZGVyLXJhZGl1c109XCJyYWRpdXNcIlxuICAgICAgPjwvZGl2PlxuICAgICAgPGRpdlxuICAgICAgICBuZ3gtY29sb3ItY29vcmRpbmF0ZXNcbiAgICAgICAgKGNvb3JkaW5hdGVzQ2hhbmdlKT1cImhhbmRsZUNoYW5nZSgkZXZlbnQpXCJcbiAgICAgICAgY2xhc3M9XCJzaGFkZS1jb250YWluZXJcIlxuICAgICAgPlxuICAgICAgICA8ZGl2XG4gICAgICAgICAgY2xhc3M9XCJzaGFkZS1wb2ludGVyXCJcbiAgICAgICAgICBbc3R5bGUubGVmdC4lXT1cInBvaW50ZXJMZWZ0XCJcbiAgICAgICAgICBbc3R5bGUudG9wLiVdPVwicG9pbnRlclRvcFwiXG4gICAgICAgID5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwic2hhZGUtc2xpZGVyXCIgW25nU3R5bGVdPVwicG9pbnRlclwiPjwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICBgLFxuICBzdHlsZXM6IFtcbiAgICBgXG4gICAgLnNoYWRlIHtcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIHRvcDogMDtcbiAgICAgIGJvdHRvbTogMDtcbiAgICAgIGxlZnQ6IDA7XG4gICAgICByaWdodDogMDtcbiAgICB9XG4gICAgLnNoYWRlLWdyYWRpZW50IHtcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIHRvcDogMDtcbiAgICAgIGJvdHRvbTogMDtcbiAgICAgIGxlZnQ6IDA7XG4gICAgICByaWdodDogMDtcbiAgICB9XG4gICAgLnNoYWRlLWNvbnRhaW5lciB7XG4gICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICBtYXJnaW46IDAgM3B4O1xuICAgIH1cbiAgICAuc2hhZGUtcG9pbnRlciB7XG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgfVxuICAgIC5zaGFkZS1zbGlkZXIge1xuICAgICAgd2lkdGg6IDRweDtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDFweDtcbiAgICAgIGhlaWdodDogOHB4O1xuICAgICAgYm94LXNoYWRvdzogMCAwIDJweCByZ2JhKDAsIDAsIDAsIC42KTtcbiAgICAgIGJhY2tncm91bmQ6ICNmZmY7XG4gICAgICBtYXJnaW4tdG9wOiAxcHg7XG4gICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTJweCk7XG4gICAgfSxcbiAgYCxcbiAgXSxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gIHByZXNlcnZlV2hpdGVzcGFjZXM6IGZhbHNlLFxufSlcbmV4cG9ydCBjbGFzcyBTaGFkZUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uQ2hhbmdlcyB7XG4gIEBJbnB1dCgpIGhzbDogSFNMQTtcbiAgQElucHV0KCkgcmdiOiBSR0JBO1xuICBASW5wdXQoKSBwb2ludGVyOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xuICBASW5wdXQoKSBzaGFkb3c6IHN0cmluZztcbiAgQElucHV0KCkgcmFkaXVzOiBzdHJpbmc7XG4gIEBPdXRwdXQoKSBvbkNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuICBncmFkaWVudDogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfTtcbiAgcG9pbnRlckxlZnQ6IG51bWJlcjtcbiAgcG9pbnRlclRvcDogbnVtYmVyO1xuXG4gIG5nT25DaGFuZ2VzKCkge1xuICAgIHRoaXMuZ3JhZGllbnQgPSB7XG4gICAgICBiYWNrZ3JvdW5kOiBgbGluZWFyLWdyYWRpZW50KHRvIHJpZ2h0LFxuICAgICAgICAgIGhzbCgke3RoaXMuaHNsLmh9LCA5MCUsIDU1JSksXG4gICAgICAgICAgIzAwMClgLFxuICAgIH07XG4gICAgY29uc3QgaHN2ID0gbmV3IFRpbnlDb2xvcih0aGlzLmhzbCkudG9Ic3YoKTtcbiAgICB0aGlzLnBvaW50ZXJMZWZ0ID0gMTAwIC0gKGhzdi52ICogMTAwKTtcbiAgfVxuXG4gIGhhbmRsZUNoYW5nZSh7IGxlZnQsIGNvbnRhaW5lcldpZHRoLCAkZXZlbnQgfSkge1xuICAgIGxldCBkYXRhO1xuICAgIGxldCB2OiBudW1iZXI7XG4gICAgaWYgKGxlZnQgPCAwKSB7XG4gICAgICB2ID0gMDtcbiAgICB9IGVsc2UgaWYgKGxlZnQgPiBjb250YWluZXJXaWR0aCkge1xuICAgICAgdiA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHYgPSBNYXRoLnJvdW5kKChsZWZ0ICogMTAwKSAvIGNvbnRhaW5lcldpZHRoKSAvIDEwMDtcbiAgICB9XG5cbiAgICBjb25zdCBoc3YgPSBuZXcgVGlueUNvbG9yKHRoaXMuaHNsKS50b0hzdigpO1xuICAgIGlmIChoc3YudiAhPT0gdikge1xuICAgICAgZGF0YSA9IHtcbiAgICAgICAgaDogdGhpcy5oc2wuaCxcbiAgICAgICAgczogMTAwLFxuICAgICAgICB2OiAxIC0gdixcbiAgICAgICAgbDogdGhpcy5oc2wubCxcbiAgICAgICAgYTogdGhpcy5oc2wuYSxcbiAgICAgICAgc291cmNlOiAncmdiJyxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLm9uQ2hhbmdlLmVtaXQoeyBkYXRhLCAkZXZlbnQgfSk7XG4gIH1cbn1cblxuQE5nTW9kdWxlKHtcbiAgZGVjbGFyYXRpb25zOiBbU2hhZGVDb21wb25lbnRdLFxuICBleHBvcnRzOiBbU2hhZGVDb21wb25lbnRdLFxuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBDb29yZGluYXRlc01vZHVsZV0sXG59KVxuZXhwb3J0IGNsYXNzIFNoYWRlTW9kdWxlIHt9XG4iXX0=