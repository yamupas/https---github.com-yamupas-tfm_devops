import { __decorate } from "tslib";
import { CommonModule } from '@angular/common';
import { ChangeDetectionStrategy, Component, Input, NgModule, } from '@angular/core';
import { AlphaModule, CheckboardModule, ColorWrap, EditableInputModule, HueModule, SaturationModule, } from 'ngx-color';
import { ChromeFieldsComponent } from './chrome-fields.component';
let ChromeComponent = class ChromeComponent extends ColorWrap {
    constructor() {
        super();
        /** Remove alpha slider and options from picker */
        this.disableAlpha = false;
        this.circle = {
            width: '12px',
            height: '12px',
            borderRadius: '6px',
            boxShadow: 'rgb(255, 255, 255) 0px 0px 0px 1px inset',
            transform: 'translate(-6px, -8px)',
        };
        this.pointer = {
            width: '12px',
            height: '12px',
            borderRadius: '6px',
            transform: 'translate(-6px, -2px)',
            backgroundColor: 'rgb(248, 248, 248)',
            boxShadow: '0 1px 4px 0 rgba(0, 0, 0, 0.37)',
        };
    }
    afterValidChange() {
        const alpha = this.disableAlpha ? 1 : this.rgb.a;
        this.activeBackground = `rgba(${this.rgb.r}, ${this.rgb.g}, ${this.rgb.b}, ${alpha})`;
    }
    handleValueChange({ data, $event }) {
        this.handleChange(data, $event);
    }
};
__decorate([
    Input()
], ChromeComponent.prototype, "disableAlpha", void 0);
ChromeComponent = __decorate([
    Component({
        selector: 'color-chrome',
        template: `
  <div class="chrome-picker {{ className }}">
    <div class="saturation">
      <color-saturation
        [hsl]="hsl"
        [hsv]="hsv"
        [circle]="circle"
        (onChange)="handleValueChange($event)"
      ></color-saturation>
    </div>
    <div class="chrome-body">
      <div class="chrome-controls">
        <div class="chrome-color">
          <div class="chrome-swatch">
            <div class="chrome-active"
              [style.background]="activeBackground"
            ></div>
            <color-checkboard></color-checkboard>
          </div>
        </div>
        <div class="chrome-toggles">
          <div class="chrome-hue">
            <color-hue
              [radius]="2"
              [hsl]="hsl"
              [pointer]="pointer"
              (onChange)="handleValueChange($event)"
            ></color-hue>
          </div>
          <div class="chrome-alpha" *ngIf="!disableAlpha">
            <color-alpha
              [radius]="2" [rgb]="rgb" [hsl]="hsl"
              [pointer]="pointer" (onChange)="handleValueChange($event)"
            ></color-alpha>
          </div>
        </div>
      </div>
      <color-chrome-fields
        [rgb]="rgb" [hsl]="hsl" [hex]="hex"
        [disableAlpha]="disableAlpha"
        (onChange)="handleValueChange($event)"
      ></color-chrome-fields>
    </div>
  </div>
  `,
        changeDetection: ChangeDetectionStrategy.OnPush,
        preserveWhitespaces: false,
        styles: [`
      .chrome-picker {
        background: #fff;
        border-radius: 2px;
        box-shadow: 0 0 2px rgba(0, 0, 0, 0.3), 0 4px 8px rgba(0, 0, 0, 0.3);
        box-sizing: initial;
        width: 225px;
        font-family: 'Menlo';
      }
      .chrome-controls {
        display: flex;
      }
      .chrome-color {
        width: 42px;
      }
      .chrome-body {
        padding: 14px 14px 12px;
      }
      .chrome-active {
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        border-radius: 20px;
        box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.1);
        z-index: 2;
      }
      .chrome-swatch {
        width: 28px;
        height: 28px;
        border-radius: 15px;
        position: relative;
        overflow: hidden;
      }
      .saturation {
        width: 100%;
        padding-bottom: 55%;
        position: relative;
        border-radius: 2px 2px 0 0;
        overflow: hidden;
      }
      .chrome-toggles {
        flex: 1;
      }
      .chrome-hue {
        height: 10px;
        position: relative;
        margin-bottom: 8px;
      }
      .chrome-alpha {
        height: 10px;
        position: relative;
      }
    `]
    })
], ChromeComponent);
export { ChromeComponent };
let ColorChromeModule = class ColorChromeModule {
};
ColorChromeModule = __decorate([
    NgModule({
        declarations: [ChromeComponent, ChromeFieldsComponent],
        exports: [ChromeComponent, ChromeFieldsComponent],
        imports: [
            CommonModule,
            AlphaModule,
            CheckboardModule,
            EditableInputModule,
            HueModule,
            SaturationModule,
        ],
    })
], ColorChromeModule);
export { ColorChromeModule };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hyb21lLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25neC1jb2xvci9jaHJvbWUvIiwic291cmNlcyI6WyJjaHJvbWUuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDL0MsT0FBTyxFQUNMLHVCQUF1QixFQUN2QixTQUFTLEVBQ1QsS0FBSyxFQUNMLFFBQVEsR0FDVCxNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQ0wsV0FBVyxFQUNYLGdCQUFnQixFQUNoQixTQUFTLEVBQ1QsbUJBQW1CLEVBQ25CLFNBQVMsRUFDVCxnQkFBZ0IsR0FDakIsTUFBTSxXQUFXLENBQUM7QUFDbkIsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUE2R2xFLElBQWEsZUFBZSxHQUE1QixNQUFhLGVBQWdCLFNBQVEsU0FBUztJQW9CNUM7UUFDRSxLQUFLLEVBQUUsQ0FBQztRQXBCVixrREFBa0Q7UUFDekMsaUJBQVksR0FBRyxLQUFLLENBQUM7UUFDOUIsV0FBTSxHQUE4QjtZQUNsQyxLQUFLLEVBQUUsTUFBTTtZQUNiLE1BQU0sRUFBRSxNQUFNO1lBQ2QsWUFBWSxFQUFFLEtBQUs7WUFDbkIsU0FBUyxFQUFFLDBDQUEwQztZQUNyRCxTQUFTLEVBQUUsdUJBQXVCO1NBQ25DLENBQUM7UUFDRixZQUFPLEdBQThCO1lBQ25DLEtBQUssRUFBRSxNQUFNO1lBQ2IsTUFBTSxFQUFFLE1BQU07WUFDZCxZQUFZLEVBQUUsS0FBSztZQUNuQixTQUFTLEVBQUUsdUJBQXVCO1lBQ2xDLGVBQWUsRUFBRSxvQkFBb0I7WUFDckMsU0FBUyxFQUFFLGlDQUFpQztTQUM3QyxDQUFDO0lBS0YsQ0FBQztJQUVELGdCQUFnQjtRQUNkLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDakQsSUFBSSxDQUFDLGdCQUFnQixHQUFHLFFBQVEsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssS0FBSyxHQUFHLENBQUM7SUFDeEYsQ0FBQztJQUNELGlCQUFpQixDQUFDLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRTtRQUNoQyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsQ0FBQztJQUNsQyxDQUFDO0NBQ0YsQ0FBQTtBQTdCVTtJQUFSLEtBQUssRUFBRTtxREFBc0I7QUFGbkIsZUFBZTtJQTNHM0IsU0FBUyxDQUFDO1FBQ1QsUUFBUSxFQUFFLGNBQWM7UUFDeEIsUUFBUSxFQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQTRDVDtRQTBERCxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTtRQUMvQyxtQkFBbUIsRUFBRSxLQUFLO2lCQXpEeEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQXNEQztLQUlKLENBQUM7R0FDVyxlQUFlLENBK0IzQjtTQS9CWSxlQUFlO0FBNkM1QixJQUFhLGlCQUFpQixHQUE5QixNQUFhLGlCQUFpQjtDQUFHLENBQUE7QUFBcEIsaUJBQWlCO0lBWjdCLFFBQVEsQ0FBQztRQUNSLFlBQVksRUFBRSxDQUFDLGVBQWUsRUFBRSxxQkFBcUIsQ0FBQztRQUN0RCxPQUFPLEVBQUUsQ0FBQyxlQUFlLEVBQUUscUJBQXFCLENBQUM7UUFDakQsT0FBTyxFQUFFO1lBQ1AsWUFBWTtZQUNaLFdBQVc7WUFDWCxnQkFBZ0I7WUFDaEIsbUJBQW1CO1lBQ25CLFNBQVM7WUFDVCxnQkFBZ0I7U0FDakI7S0FDRixDQUFDO0dBQ1csaUJBQWlCLENBQUc7U0FBcEIsaUJBQWlCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7XG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBDb21wb25lbnQsXG4gIElucHV0LFxuICBOZ01vZHVsZSxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7XG4gIEFscGhhTW9kdWxlLFxuICBDaGVja2JvYXJkTW9kdWxlLFxuICBDb2xvcldyYXAsXG4gIEVkaXRhYmxlSW5wdXRNb2R1bGUsXG4gIEh1ZU1vZHVsZSxcbiAgU2F0dXJhdGlvbk1vZHVsZSxcbn0gZnJvbSAnbmd4LWNvbG9yJztcbmltcG9ydCB7IENocm9tZUZpZWxkc0NvbXBvbmVudCB9IGZyb20gJy4vY2hyb21lLWZpZWxkcy5jb21wb25lbnQnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjb2xvci1jaHJvbWUnLFxuICB0ZW1wbGF0ZTogYFxuICA8ZGl2IGNsYXNzPVwiY2hyb21lLXBpY2tlciB7eyBjbGFzc05hbWUgfX1cIj5cbiAgICA8ZGl2IGNsYXNzPVwic2F0dXJhdGlvblwiPlxuICAgICAgPGNvbG9yLXNhdHVyYXRpb25cbiAgICAgICAgW2hzbF09XCJoc2xcIlxuICAgICAgICBbaHN2XT1cImhzdlwiXG4gICAgICAgIFtjaXJjbGVdPVwiY2lyY2xlXCJcbiAgICAgICAgKG9uQ2hhbmdlKT1cImhhbmRsZVZhbHVlQ2hhbmdlKCRldmVudClcIlxuICAgICAgPjwvY29sb3Itc2F0dXJhdGlvbj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiY2hyb21lLWJvZHlcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJjaHJvbWUtY29udHJvbHNcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNocm9tZS1jb2xvclwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJjaHJvbWUtc3dhdGNoXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2hyb21lLWFjdGl2ZVwiXG4gICAgICAgICAgICAgIFtzdHlsZS5iYWNrZ3JvdW5kXT1cImFjdGl2ZUJhY2tncm91bmRcIlxuICAgICAgICAgICAgPjwvZGl2PlxuICAgICAgICAgICAgPGNvbG9yLWNoZWNrYm9hcmQ+PC9jb2xvci1jaGVja2JvYXJkPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNocm9tZS10b2dnbGVzXCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImNocm9tZS1odWVcIj5cbiAgICAgICAgICAgIDxjb2xvci1odWVcbiAgICAgICAgICAgICAgW3JhZGl1c109XCIyXCJcbiAgICAgICAgICAgICAgW2hzbF09XCJoc2xcIlxuICAgICAgICAgICAgICBbcG9pbnRlcl09XCJwb2ludGVyXCJcbiAgICAgICAgICAgICAgKG9uQ2hhbmdlKT1cImhhbmRsZVZhbHVlQ2hhbmdlKCRldmVudClcIlxuICAgICAgICAgICAgPjwvY29sb3ItaHVlPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJjaHJvbWUtYWxwaGFcIiAqbmdJZj1cIiFkaXNhYmxlQWxwaGFcIj5cbiAgICAgICAgICAgIDxjb2xvci1hbHBoYVxuICAgICAgICAgICAgICBbcmFkaXVzXT1cIjJcIiBbcmdiXT1cInJnYlwiIFtoc2xdPVwiaHNsXCJcbiAgICAgICAgICAgICAgW3BvaW50ZXJdPVwicG9pbnRlclwiIChvbkNoYW5nZSk9XCJoYW5kbGVWYWx1ZUNoYW5nZSgkZXZlbnQpXCJcbiAgICAgICAgICAgID48L2NvbG9yLWFscGhhPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICAgPGNvbG9yLWNocm9tZS1maWVsZHNcbiAgICAgICAgW3JnYl09XCJyZ2JcIiBbaHNsXT1cImhzbFwiIFtoZXhdPVwiaGV4XCJcbiAgICAgICAgW2Rpc2FibGVBbHBoYV09XCJkaXNhYmxlQWxwaGFcIlxuICAgICAgICAob25DaGFuZ2UpPVwiaGFuZGxlVmFsdWVDaGFuZ2UoJGV2ZW50KVwiXG4gICAgICA+PC9jb2xvci1jaHJvbWUtZmllbGRzPlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbiAgYCxcbiAgc3R5bGVzOiBbXG4gICAgYFxuICAgICAgLmNocm9tZS1waWNrZXIge1xuICAgICAgICBiYWNrZ3JvdW5kOiAjZmZmO1xuICAgICAgICBib3JkZXItcmFkaXVzOiAycHg7XG4gICAgICAgIGJveC1zaGFkb3c6IDAgMCAycHggcmdiYSgwLCAwLCAwLCAwLjMpLCAwIDRweCA4cHggcmdiYSgwLCAwLCAwLCAwLjMpO1xuICAgICAgICBib3gtc2l6aW5nOiBpbml0aWFsO1xuICAgICAgICB3aWR0aDogMjI1cHg7XG4gICAgICAgIGZvbnQtZmFtaWx5OiAnTWVubG8nO1xuICAgICAgfVxuICAgICAgLmNocm9tZS1jb250cm9scyB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICB9XG4gICAgICAuY2hyb21lLWNvbG9yIHtcbiAgICAgICAgd2lkdGg6IDQycHg7XG4gICAgICB9XG4gICAgICAuY2hyb21lLWJvZHkge1xuICAgICAgICBwYWRkaW5nOiAxNHB4IDE0cHggMTJweDtcbiAgICAgIH1cbiAgICAgIC5jaHJvbWUtYWN0aXZlIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIGJvdHRvbTogMDtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgcmlnaHQ6IDA7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDIwcHg7XG4gICAgICAgIGJveC1zaGFkb3c6IGluc2V0IDAgMCAwIDFweCByZ2JhKDAsIDAsIDAsIDAuMSk7XG4gICAgICAgIHotaW5kZXg6IDI7XG4gICAgICB9XG4gICAgICAuY2hyb21lLXN3YXRjaCB7XG4gICAgICAgIHdpZHRoOiAyOHB4O1xuICAgICAgICBoZWlnaHQ6IDI4cHg7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDE1cHg7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgIH1cbiAgICAgIC5zYXR1cmF0aW9uIHtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIHBhZGRpbmctYm90dG9tOiA1NSU7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMnB4IDJweCAwIDA7XG4gICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICB9XG4gICAgICAuY2hyb21lLXRvZ2dsZXMge1xuICAgICAgICBmbGV4OiAxO1xuICAgICAgfVxuICAgICAgLmNocm9tZS1odWUge1xuICAgICAgICBoZWlnaHQ6IDEwcHg7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogOHB4O1xuICAgICAgfVxuICAgICAgLmNocm9tZS1hbHBoYSB7XG4gICAgICAgIGhlaWdodDogMTBweDtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgfVxuICAgIGAsXG4gIF0sXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICBwcmVzZXJ2ZVdoaXRlc3BhY2VzOiBmYWxzZSxcbn0pXG5leHBvcnQgY2xhc3MgQ2hyb21lQ29tcG9uZW50IGV4dGVuZHMgQ29sb3JXcmFwIHtcbiAgLyoqIFJlbW92ZSBhbHBoYSBzbGlkZXIgYW5kIG9wdGlvbnMgZnJvbSBwaWNrZXIgKi9cbiAgQElucHV0KCkgZGlzYWJsZUFscGhhID0gZmFsc2U7XG4gIGNpcmNsZTogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHtcbiAgICB3aWR0aDogJzEycHgnLFxuICAgIGhlaWdodDogJzEycHgnLFxuICAgIGJvcmRlclJhZGl1czogJzZweCcsXG4gICAgYm94U2hhZG93OiAncmdiKDI1NSwgMjU1LCAyNTUpIDBweCAwcHggMHB4IDFweCBpbnNldCcsXG4gICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKC02cHgsIC04cHgpJyxcbiAgfTtcbiAgcG9pbnRlcjogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHtcbiAgICB3aWR0aDogJzEycHgnLFxuICAgIGhlaWdodDogJzEycHgnLFxuICAgIGJvcmRlclJhZGl1czogJzZweCcsXG4gICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKC02cHgsIC0ycHgpJyxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2IoMjQ4LCAyNDgsIDI0OCknLFxuICAgIGJveFNoYWRvdzogJzAgMXB4IDRweCAwIHJnYmEoMCwgMCwgMCwgMC4zNyknLFxuICB9O1xuICBhY3RpdmVCYWNrZ3JvdW5kOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIGFmdGVyVmFsaWRDaGFuZ2UoKSB7XG4gICAgY29uc3QgYWxwaGEgPSB0aGlzLmRpc2FibGVBbHBoYSA/IDEgOiB0aGlzLnJnYi5hO1xuICAgIHRoaXMuYWN0aXZlQmFja2dyb3VuZCA9IGByZ2JhKCR7dGhpcy5yZ2Iucn0sICR7dGhpcy5yZ2IuZ30sICR7dGhpcy5yZ2IuYn0sICR7YWxwaGF9KWA7XG4gIH1cbiAgaGFuZGxlVmFsdWVDaGFuZ2UoeyBkYXRhLCAkZXZlbnQgfSkge1xuICAgIHRoaXMuaGFuZGxlQ2hhbmdlKGRhdGEsICRldmVudCk7XG4gIH1cbn1cblxuQE5nTW9kdWxlKHtcbiAgZGVjbGFyYXRpb25zOiBbQ2hyb21lQ29tcG9uZW50LCBDaHJvbWVGaWVsZHNDb21wb25lbnRdLFxuICBleHBvcnRzOiBbQ2hyb21lQ29tcG9uZW50LCBDaHJvbWVGaWVsZHNDb21wb25lbnRdLFxuICBpbXBvcnRzOiBbXG4gICAgQ29tbW9uTW9kdWxlLFxuICAgIEFscGhhTW9kdWxlLFxuICAgIENoZWNrYm9hcmRNb2R1bGUsXG4gICAgRWRpdGFibGVJbnB1dE1vZHVsZSxcbiAgICBIdWVNb2R1bGUsXG4gICAgU2F0dXJhdGlvbk1vZHVsZSxcbiAgXSxcbn0pXG5leHBvcnQgY2xhc3MgQ29sb3JDaHJvbWVNb2R1bGUge31cbiJdfQ==