import { __decorate } from "tslib";
import { CommonModule } from '@angular/common';
import { ChangeDetectionStrategy, Component, EventEmitter, Input, NgModule, Output, } from '@angular/core';
import { fromEvent } from 'rxjs';
let EditableInputComponent = class EditableInputComponent {
    constructor() {
        this.placeholder = '';
        this.onChange = new EventEmitter();
        this.focus = false;
    }
    ngOnInit() {
        this.wrapStyle = this.style && this.style.wrap ? this.style.wrap : {};
        this.inputStyle = this.style && this.style.input ? this.style.input : {};
        this.labelStyle = this.style && this.style.label ? this.style.label : {};
        if (this.dragLabel) {
            this.labelStyle.cursor = 'ew-resize';
        }
    }
    handleFocus($event) {
        this.focus = true;
    }
    handleFocusOut($event) {
        this.focus = false;
        this.currentValue = this.blurValue;
    }
    handleKeydown($event) {
        // In case `e.target.value` is a percentage remove the `%` character
        // and update accordingly with a percentage
        // https://github.com/casesandberg/react-color/issues/383
        const stringValue = String($event.target.value);
        const isPercentage = stringValue.indexOf('%') > -1;
        const num = Number(stringValue.replace(/%/g, ''));
        if (!isNaN(num)) {
            const amount = this.arrowOffset || 1;
            // Up
            if ($event.keyCode === 38) {
                if (this.label) {
                    this.onChange.emit({
                        data: { [this.label]: num + amount },
                        $event,
                    });
                }
                else {
                    this.onChange.emit({ data: num + amount, $event });
                }
                if (isPercentage) {
                    this.currentValue = `${num + amount}%`;
                }
                else {
                    this.currentValue = num + amount;
                }
            }
            // Down
            if ($event.keyCode === 40) {
                if (this.label) {
                    this.onChange.emit({
                        data: { [this.label]: num - amount },
                        $event,
                    });
                }
                else {
                    this.onChange.emit({ data: num - amount, $event });
                }
                if (isPercentage) {
                    this.currentValue = `${num - amount}%`;
                }
                else {
                    this.currentValue = num - amount;
                }
            }
        }
    }
    handleKeyup($event) {
        if ($event.keyCode === 40 || $event.keyCode === 38) {
            return;
        }
        if (this.label) {
            this.onChange.emit({
                data: { [this.label]: $event.target.value },
                $event,
            });
        }
        else {
            this.onChange.emit({ data: $event.target.value, $event });
        }
    }
    ngOnChanges() {
        if (!this.focus) {
            this.currentValue = String(this.value).toUpperCase();
            this.blurValue = String(this.value).toUpperCase();
        }
        else {
            this.blurValue = String(this.value).toUpperCase();
        }
    }
    ngOnDestroy() {
        this.unsubscribe();
    }
    subscribe() {
        this.mousemove = fromEvent(document, 'mousemove').subscribe((ev) => this.handleDrag(ev));
        this.mouseup = fromEvent(document, 'mouseup').subscribe(() => this.unsubscribe());
    }
    unsubscribe() {
        if (this.mousemove) {
            this.mousemove.unsubscribe();
        }
        if (this.mouseup) {
            this.mouseup.unsubscribe();
        }
    }
    handleMousedown($event) {
        if (this.dragLabel) {
            $event.preventDefault();
            this.handleDrag($event);
            this.subscribe();
        }
    }
    handleDrag($event) {
        if (this.dragLabel) {
            const newValue = Math.round(this.value + $event.movementX);
            if (newValue >= 0 && newValue <= this.dragMax) {
                this.onChange.emit({ data: { [this.label]: newValue }, $event });
            }
        }
    }
};
__decorate([
    Input()
], EditableInputComponent.prototype, "style", void 0);
__decorate([
    Input()
], EditableInputComponent.prototype, "label", void 0);
__decorate([
    Input()
], EditableInputComponent.prototype, "value", void 0);
__decorate([
    Input()
], EditableInputComponent.prototype, "arrowOffset", void 0);
__decorate([
    Input()
], EditableInputComponent.prototype, "dragLabel", void 0);
__decorate([
    Input()
], EditableInputComponent.prototype, "dragMax", void 0);
__decorate([
    Input()
], EditableInputComponent.prototype, "placeholder", void 0);
__decorate([
    Output()
], EditableInputComponent.prototype, "onChange", void 0);
EditableInputComponent = __decorate([
    Component({
        selector: 'color-editable-input',
        template: `
  <div class="wrap" [ngStyle]="wrapStyle">
    <input [ngStyle]="inputStyle" spellCheck="false"
      [value]="currentValue" [placeholder]="placeholder"
      (keydown)="handleKeydown($event)" (keyup)="handleKeyup($event)"
      (focus)="handleFocus($event)" (focusout)="handleFocusOut($event)" />
    <span *ngIf="label" [ngStyle]="labelStyle" (mousedown)="handleMousedown($event)">
      {{ label }}
    </span>
  </div>
  `,
        changeDetection: ChangeDetectionStrategy.OnPush,
        styles: [`
    :host {
      display: flex;
    }
    .wrap {
      position: relative;
    }
  `]
    })
], EditableInputComponent);
export { EditableInputComponent };
let EditableInputModule = class EditableInputModule {
};
EditableInputModule = __decorate([
    NgModule({
        declarations: [EditableInputComponent],
        exports: [EditableInputComponent],
        imports: [CommonModule],
    })
], EditableInputModule);
export { EditableInputModule };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWRpdGFibGUtaW5wdXQuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LWNvbG9yLyIsInNvdXJjZXMiOlsiZWRpdGFibGUtaW5wdXQuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDL0MsT0FBTyxFQUNMLHVCQUF1QixFQUN2QixTQUFTLEVBQ1QsWUFBWSxFQUNaLEtBQUssRUFDTCxRQUFRLEVBSVIsTUFBTSxHQUNQLE1BQU0sZUFBZSxDQUFDO0FBRXZCLE9BQU8sRUFBRSxTQUFTLEVBQWdCLE1BQU0sTUFBTSxDQUFDO0FBMkIvQyxJQUFhLHNCQUFzQixHQUFuQyxNQUFhLHNCQUFzQjtJQUFuQztRQVdXLGdCQUFXLEdBQUcsRUFBRSxDQUFDO1FBQ2hCLGFBQVEsR0FBRyxJQUFJLFlBQVksRUFBRSxDQUFDO1FBTXhDLFVBQUssR0FBRyxLQUFLLENBQUM7SUF5SGhCLENBQUM7SUFySEMsUUFBUTtRQUNOLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQUN0RSxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7UUFDekUsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO1FBQ3pFLElBQUksSUFB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QUFRLEVBQUU7Ozs7Ozs7Ozs7R0FVVDtRQVdELGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNO2lCQVQ3Qzs7Ozs7OztHQU9EO0tBR0YsQ0FBQztHQUNXLHNCQUFzQixDQTJJbEM7U0EzSVksc0JBQXNCO0FBa0puQyxJQUFhLG1CQUFtQixHQUFoQyxNQUFhLG1CQUFtQjtDQUFHLENBQUE7QUFBdEIsbUJBQW1CO0lBTC9CLFFBQVEsQ0FBQztRQUNSLFlBQVksRUFBRSxDQUFDLHNCQUFzQixDQUFDO1FBQ3RDLE9BQU8sRUFBRSxDQUFDLHNCQUFzQixDQUFDO1FBQ2pDLE9BQU8sRUFBRSxDQUFDLFlBQVksQ0FBQztLQUN4QixDQUFDO0dBQ1csbUJBQW1CLENBQUc7U0FBdEIsbUJBQW1CIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7XG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBDb21wb25lbnQsXG4gIEV2ZW50RW1pdHRlcixcbiAgSW5wdXQsXG4gIE5nTW9kdWxlLFxuICBPbkNoYW5nZXMsXG4gIE9uRGVzdHJveSxcbiAgT25Jbml0LFxuICBPdXRwdXQsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBmcm9tRXZlbnQsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjb2xvci1lZGl0YWJsZS1pbnB1dCcsXG4gIHRlbXBsYXRlOiBgXG4gIDxkaXYgY2xhc3M9XCJ3cmFwXCIgW25nU3R5bGVdPVwid3JhcFN0eWxlXCI+XG4gICAgPGlucHV0IFtuZ1N0eWxlXT1cImlucHV0U3R5bGVcIiBzcGVsbENoZWNrPVwiZmFsc2VcIlxuICAgICAgW3ZhbHVlXT1cImN1cnJlbnRWYWx1ZVwiIFtwbGFjZWhvbGRlcl09XCJwbGFjZWhvbGRlclwiXG4gICAgICAoa2V5ZG93bik9XCJoYW5kbGVLZXlkb3duKCRldmVudClcIiAoa2V5dXApPVwiaGFuZGxlS2V5dXAoJGV2ZW50KVwiXG4gICAgICAoZm9jdXMpPVwiaGFuZGxlRm9jdXMoJGV2ZW50KVwiIChmb2N1c291dCk9XCJoYW5kbGVGb2N1c091dCgkZXZlbnQpXCIgLz5cbiAgICA8c3BhbiAqbmdJZj1cImxhYmVsXCIgW25nU3R5bGVdPVwibGFiZWxTdHlsZVwiIChtb3VzZWRvd24pPVwiaGFuZGxlTW91c2Vkb3duKCRldmVudClcIj5cbiAgICAgIHt7IGxhYmVsIH19XG4gICAgPC9zcGFuPlxuICA8L2Rpdj5cbiAgYCxcbiAgc3R5bGVzOiBbXG4gICAgYFxuICAgIDpob3N0IHtcbiAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgfVxuICAgIC53cmFwIHtcbiAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICB9XG4gIGAsXG4gIF0sXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxufSlcbmV4cG9ydCBjbGFzcyBFZGl0YWJsZUlucHV0Q29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSB7XG4gIEBJbnB1dCgpIHN0eWxlOiB7XG4gICAgd3JhcDogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfTtcbiAgICBpbnB1dDogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfTtcbiAgICBsYWJlbDogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfTtcbiAgfTtcbiAgQElucHV0KCkgbGFiZWw6IHN0cmluZztcbiAgQElucHV0KCkgdmFsdWU6IHN0cmluZyB8IG51bWJlcjtcbiAgQElucHV0KCkgYXJyb3dPZmZzZXQ6IG51bWJlcjtcbiAgQElucHV0KCkgZHJhZ0xhYmVsOiBib29sZWFuO1xuICBASW5wdXQoKSBkcmFnTWF4OiBudW1iZXI7XG4gIEBJbnB1dCgpIHBsYWNlaG9sZGVyID0gJyc7XG4gIEBPdXRwdXQoKSBvbkNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgY3VycmVudFZhbHVlOiBzdHJpbmcgfCBudW1iZXI7XG4gIGJsdXJWYWx1ZTogc3RyaW5nO1xuICB3cmFwU3R5bGU6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH07XG4gIGlucHV0U3R5bGU6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH07XG4gIGxhYmVsU3R5bGU6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH07XG4gIGZvY3VzID0gZmFsc2U7XG4gIG1vdXNlbW92ZTogU3Vic2NyaXB0aW9uO1xuICBtb3VzZXVwOiBTdWJzY3JpcHRpb247XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy53cmFwU3R5bGUgPSB0aGlzLnN0eWxlICYmIHRoaXMuc3R5bGUud3JhcCA/IHRoaXMuc3R5bGUud3JhcCA6IHt9O1xuICAgIHRoaXMuaW5wdXRTdHlsZSA9IHRoaXMuc3R5bGUgJiYgdGhpcy5zdHlsZS5pbnB1dCA/IHRoaXMuc3R5bGUuaW5wdXQgOiB7fTtcbiAgICB0aGlzLmxhYmVsU3R5bGUgPSB0aGlzLnN0eWxlICYmIHRoaXMuc3R5bGUubGFiZWwgPyB0aGlzLnN0eWxlLmxhYmVsIDoge307XG4gICAgaWYgKHRoaXMuZHJhZ0xhYmVsKSB7XG4gICAgICB0aGlzLmxhYmVsU3R5bGUuY3Vyc29yID0gJ2V3LXJlc2l6ZSc7XG4gICAgfVxuICB9XG4gIGhhbmRsZUZvY3VzKCRldmVudCkge1xuICAgIHRoaXMuZm9jdXMgPSB0cnVlO1xuICB9XG4gIGhhbmRsZUZvY3VzT3V0KCRldmVudCkge1xuICAgIHRoaXMuZm9jdXMgPSBmYWxzZTtcbiAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IHRoaXMuYmx1clZhbHVlO1xuICB9XG4gIGhhbmRsZUtleWRvd24oJGV2ZW50KSB7XG4gICAgLy8gSW4gY2FzZSBgZS50YXJnZXQudmFsdWVgIGlzIGEgcGVyY2VudGFnZSByZW1vdmUgdGhlIGAlYCBjaGFyYWN0ZXJcbiAgICAvLyBhbmQgdXBkYXRlIGFjY29yZGluZ2x5IHdpdGggYSBwZXJjZW50YWdlXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Nhc2VzYW5kYmVyZy9yZWFjdC1jb2xvci9pc3N1ZXMvMzgzXG4gICAgY29uc3Qgc3RyaW5nVmFsdWUgPSBTdHJpbmcoJGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gICAgY29uc3QgaXNQZXJjZW50YWdlID0gc3RyaW5nVmFsdWUuaW5kZXhPZignJScpID4gLTE7XG4gICAgY29uc3QgbnVtID0gTnVtYmVyKHN0cmluZ1ZhbHVlLnJlcGxhY2UoLyUvZywgJycpKTtcbiAgICBpZiAoIWlzTmFOKG51bSkpIHtcbiAgICAgIGNvbnN0IGFtb3VudCA9IHRoaXMuYXJyb3dPZmZzZXQgfHwgMTtcblxuICAgICAgLy8gVXBcbiAgICAgIGlmICgkZXZlbnQua2V5Q29kZSA9PT0gMzgpIHtcbiAgICAgICAgaWYgKHRoaXMubGFiZWwpIHtcbiAgICAgICAgICB0aGlzLm9uQ2hhbmdlLmVtaXQoe1xuICAgICAgICAgICAgZGF0YTogeyBbdGhpcy5sYWJlbF06IG51bSArIGFtb3VudCB9LFxuICAgICAgICAgICAgJGV2ZW50LFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub25DaGFuZ2UuZW1pdCh7IGRhdGE6IG51bSArIGFtb3VudCwgJGV2ZW50IH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzUGVyY2VudGFnZSkge1xuICAgICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gYCR7bnVtICsgYW1vdW50fSVgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gbnVtICsgYW1vdW50O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIERvd25cbiAgICAgIGlmICgkZXZlbnQua2V5Q29kZSA9PT0gNDApIHtcbiAgICAgICAgaWYgKHRoaXMubGFiZWwpIHtcbiAgICAgICAgICB0aGlzLm9uQ2hhbmdlLmVtaXQoe1xuICAgICAgICAgICAgZGF0YTogeyBbdGhpcy5sYWJlbF06IG51bSAtIGFtb3VudCB9LFxuICAgICAgICAgICAgJGV2ZW50LFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub25DaGFuZ2UuZW1pdCh7IGRhdGE6IG51bSAtIGFtb3VudCwgJGV2ZW50IH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzUGVyY2VudGFnZSkge1xuICAgICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gYCR7bnVtIC0gYW1vdW50fSVgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gbnVtIC0gYW1vdW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGhhbmRsZUtleXVwKCRldmVudCkge1xuICAgIGlmICgkZXZlbnQua2V5Q29kZSA9PT0gNDAgfHwgJGV2ZW50LmtleUNvZGUgPT09IDM4KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmxhYmVsKSB7XG4gICAgICB0aGlzLm9uQ2hhbmdlLmVtaXQoe1xuICAgICAgICBkYXRhOiB7IFt0aGlzLmxhYmVsXTogJGV2ZW50LnRhcmdldC52YWx1ZSB9LFxuICAgICAgICAkZXZlbnQsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vbkNoYW5nZS5lbWl0KHsgZGF0YTogJGV2ZW50LnRhcmdldC52YWx1ZSwgJGV2ZW50IH0pO1xuICAgIH1cbiAgfVxuICBuZ09uQ2hhbmdlcygpIHtcbiAgICBpZiAoIXRoaXMuZm9jdXMpIHtcbiAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gU3RyaW5nKHRoaXMudmFsdWUpLnRvVXBwZXJDYXNlKCk7XG4gICAgICB0aGlzLmJsdXJWYWx1ZSA9IFN0cmluZyh0aGlzLnZhbHVlKS50b1VwcGVyQ2FzZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJsdXJWYWx1ZSA9IFN0cmluZyh0aGlzLnZhbHVlKS50b1VwcGVyQ2FzZSgpO1xuICAgIH1cbiAgfVxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gIH1cbiAgc3Vic2NyaWJlKCkge1xuICAgIHRoaXMubW91c2Vtb3ZlID0gZnJvbUV2ZW50KGRvY3VtZW50LCAnbW91c2Vtb3ZlJykuc3Vic2NyaWJlKChldjogRXZlbnQpID0+XG4gICAgICB0aGlzLmhhbmRsZURyYWcoZXYpLFxuICAgICk7XG4gICAgdGhpcy5tb3VzZXVwID0gZnJvbUV2ZW50KGRvY3VtZW50LCAnbW91c2V1cCcpLnN1YnNjcmliZSgoKSA9PlxuICAgICAgdGhpcy51bnN1YnNjcmliZSgpLFxuICAgICk7XG4gIH1cbiAgdW5zdWJzY3JpYmUoKSB7XG4gICAgaWYgKHRoaXMubW91c2Vtb3ZlKSB7XG4gICAgICB0aGlzLm1vdXNlbW92ZS51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5tb3VzZXVwKSB7XG4gICAgICB0aGlzLm1vdXNldXAudW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH1cbiAgaGFuZGxlTW91c2Vkb3duKCRldmVudDogRXZlbnQpIHtcbiAgICBpZiAodGhpcy5kcmFnTGFiZWwpIHtcbiAgICAgICRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5oYW5kbGVEcmFnKCRldmVudCk7XG4gICAgICB0aGlzLnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfVxuICBoYW5kbGVEcmFnKCRldmVudCkge1xuICAgIGlmICh0aGlzLmRyYWdMYWJlbCkge1xuICAgICAgY29uc3QgbmV3VmFsdWUgPSBNYXRoLnJvdW5kKHRoaXMudmFsdWUgKyAkZXZlbnQubW92ZW1lbnRYKTtcbiAgICAgIGlmIChuZXdWYWx1ZSA+PSAwICYmIG5ld1ZhbHVlIDw9IHRoaXMuZHJhZ01heCkge1xuICAgICAgICB0aGlzLm9uQ2hhbmdlLmVtaXQoeyBkYXRhOiB7IFt0aGlzLmxhYmVsXTogbmV3VmFsdWUgfSwgJGV2ZW50IH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5ATmdNb2R1bGUoe1xuICBkZWNsYXJhdGlvbnM6IFtFZGl0YWJsZUlucHV0Q29tcG9uZW50XSxcbiAgZXhwb3J0czogW0VkaXRhYmxlSW5wdXRDb21wb25lbnRdLFxuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXSxcbn0pXG5leHBvcnQgY2xhc3MgRWRpdGFibGVJbnB1dE1vZHVsZSB7fVxuIl19