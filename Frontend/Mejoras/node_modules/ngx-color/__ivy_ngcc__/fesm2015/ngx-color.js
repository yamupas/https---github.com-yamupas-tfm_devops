import { __decorate } from 'tslib';
import { CommonModule } from '@angular/common';
import { Input, Component, ChangeDetectionStrategy, NgModule, ElementRef, Output, HostListener, Directive, EventEmitter } from '@angular/core';
import { Subject, fromEvent } from 'rxjs';
import { distinctUntilChanged, debounceTime } from 'rxjs/operators';
import { TinyColor } from '@ctrl/tinycolor';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

function EditableInputComponent_span_2_Template(rf, ctx) { if (rf & 1) {
    const _r2 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "span", 3);
    ɵngcc0.ɵɵlistener("mousedown", function EditableInputComponent_span_2_Template_span_mousedown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r2); const ctx_r1 = ɵngcc0.ɵɵnextContext(); return ctx_r1.handleMousedown($event); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngStyle", ctx_r0.labelStyle);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r0.label, " ");
} }
function HueComponent_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 2);
    ɵngcc0.ɵɵelement(1, "div", 3);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("left", ctx_r0.left)("top", ctx_r0.top);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngStyle", ctx_r0.pointer);
} }
const _c0 = ["*"];
function SwatchComponent_color_checkboard_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "color-checkboard", 2);
} }
const checkboardCache = {};
function render(c1, c2, size) {
    if (typeof document === 'undefined') {
        return null;
    }
    const canvas = document.createElement('canvas');
    canvas.width = size * 2;
    canvas.height = size * 2;
    const ctx = canvas.getContext('2d');
    if (!ctx) {
        return null;
    } // If no context can be found, return early.
    ctx.fillStyle = c1;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = c2;
    ctx.fillRect(0, 0, size, size);
    ctx.translate(size, size);
    ctx.fillRect(0, 0, size, size);
    return canvas.toDataURL();
}
function getCheckerboard(c1, c2, size) {
    const key = `${c1}-${c2}-${size}`;
    if (checkboardCache[key]) {
        return checkboardCache[key];
    }
    const checkboard = render(c1, c2, size);
    if (!checkboard) {
        return null;
    }
    checkboardCache[key] = checkboard;
    return checkboard;
}

let CheckboardComponent = class CheckboardComponent {
    constructor() {
        this.white = 'transparent';
        this.size = 8;
        this.grey = 'rgba(0,0,0,.08)';
    }
    ngOnInit() {
        const background = getCheckerboard(this.white, this.grey, this.size);
        this.gridStyles = {
            borderRadius: this.borderRadius,
            boxShadow: this.boxShadow,
            background: `url(${background}) center left`,
        };
    }
};
CheckboardComponent.ɵfac = function CheckboardComponent_Factory(t) { return new (t || CheckboardComponent)(); };
CheckboardComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CheckboardComponent, selectors: [["color-checkboard"]], inputs: { white: "white", size: "size", grey: "grey", boxShadow: "boxShadow", borderRadius: "borderRadius" }, decls: 1, vars: 1, consts: [[1, "grid", 3, "ngStyle"]], template: function CheckboardComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "div", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngStyle", ctx.gridStyles);
    } }, directives: [ɵngcc1.NgStyle], styles: [".grid[_ngcontent-%COMP%] {\n    top: 0px;\n    right: 0px;\n    bottom: 0px;\n    left: 0px;\n    position: absolute;\n  }"], changeDetection: 0 });
__decorate([
    Input()
], CheckboardComponent.prototype, "white", void 0);
__decorate([
    Input()
], CheckboardComponent.prototype, "size", void 0);
__decorate([
    Input()
], CheckboardComponent.prototype, "grey", void 0);
__decorate([
    Input()
], CheckboardComponent.prototype, "boxShadow", void 0);
__decorate([
    Input()
], CheckboardComponent.prototype, "borderRadius", void 0);
let CheckboardModule = class CheckboardModule {
};
CheckboardModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: CheckboardModule });
CheckboardModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function CheckboardModule_Factory(t) { return new (t || CheckboardModule)(); }, imports: [[CommonModule]] });

let CoordinatesDirective = class CoordinatesDirective {
    constructor(el) {
        this.el = el;
        this.coordinatesChange = new Subject();
        this.mousechange = new Subject();
        this.mouseListening = false;
    }
    mousemove($event, x, y, isTouch = false) {
        if (this.mouseListening) {
            $event.preventDefault();
            this.mousechange.next({ $event, x, y, isTouch });
        }
    }
    mouseup() {
        this.mouseListening = false;
    }
    mousedown($event, x, y, isTouch = false) {
        $event.preventDefault();
        this.mouseListening = true;
        this.mousechange.next({ $event, x, y, isTouch });
    }
    ngOnInit() {
        this.sub = this.mousechange
            .pipe(
        // limit times it is updated for the same area
        distinctUntilChanged((p, q) => p.x === q.x && p.y === q.y))
            .subscribe(n => this.handleChange(n.x, n.y, n.$event, n.isTouch));
    }
    ngOnDestroy() {
        this.sub.unsubscribe();
    }
    handleChange(x, y, $event, isTouch) {
        const containerWidth = this.el.nativeElement.clientWidth;
        const containerHeight = this.el.nativeElement.clientHeight;
        const left = x -
            (this.el.nativeElement.getBoundingClientRect().left + window.pageXOffset);
        let top = y - this.el.nativeElement.getBoundingClientRect().top;
        if (!isTouch) {
            top = top - window.pageYOffset;
        }
        this.coordinatesChange.next({
            x,
            y,
            top,
            left,
            containerWidth,
            containerHeight,
            $event,
        });
    }
};
CoordinatesDirective.ɵfac = function CoordinatesDirective_Factory(t) { return new (t || CoordinatesDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
CoordinatesDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: CoordinatesDirective, selectors: [["", "ngx-color-coordinates", ""]], hostBindings: function CoordinatesDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mousemove", function CoordinatesDirective_mousemove_HostBindingHandler($event) { return ctx.mousemove($event, $event.pageX, $event.pageY); }, false, ɵngcc0.ɵɵresolveWindow)("touchmove", function CoordinatesDirective_touchmove_HostBindingHandler($event) { return ctx.mousemove($event, $event.touches[0].clientX, $event.touches[0].clientY, true); }, false, ɵngcc0.ɵɵresolveWindow)("mouseup", function CoordinatesDirective_mouseup_HostBindingHandler() { return ctx.mouseup(); }, false, ɵngcc0.ɵɵresolveWindow)("touchend", function CoordinatesDirective_touchend_HostBindingHandler() { return ctx.mouseup(); }, false, ɵngcc0.ɵɵresolveWindow)("mousedown", function CoordinatesDirective_mousedown_HostBindingHandler($event) { return ctx.mousedown($event, $event.pageX, $event.pageY); })("touchstart", function CoordinatesDirective_touchstart_HostBindingHandler($event) { return ctx.mousedown($event, $event.touches[0].clientX, $event.touches[0].clientY, true); });
    } }, outputs: { coordinatesChange: "coordinatesChange" } });
CoordinatesDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Output()
], CoordinatesDirective.prototype, "coordinatesChange", void 0);
__decorate([
    HostListener('window:mousemove', ['$event', '$event.pageX', '$event.pageY']),
    HostListener('window:touchmove', [
        '$event',
        '$event.touches[0].clientX',
        '$event.touches[0].clientY',
        'true',
    ])
], CoordinatesDirective.prototype, "mousemove", null);
__decorate([
    HostListener('window:mouseup'),
    HostListener('window:touchend')
], CoordinatesDirective.prototype, "mouseup", null);
__decorate([
    HostListener('mousedown', ['$event', '$event.pageX', '$event.pageY']),
    HostListener('touchstart', [
        '$event',
        '$event.touches[0].clientX',
        '$event.touches[0].clientY',
        'true',
    ])
], CoordinatesDirective.prototype, "mousedown", null);
let CoordinatesModule = class CoordinatesModule {
};
CoordinatesModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: CoordinatesModule });
CoordinatesModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function CoordinatesModule_Factory(t) { return new (t || CoordinatesModule)(); } });

let AlphaComponent = class AlphaComponent {
    constructor() {
        this.direction = 'horizontal';
        this.onChange = new EventEmitter();
    }
    ngOnChanges() {
        if (this.direction === 'vertical') {
            this.pointerLeft = 0;
            this.pointerTop = this.rgb.a * 100;
            this.gradient = {
                background: `linear-gradient(to bottom, rgba(${this.rgb.r},${this.rgb.g},${this.rgb.b}, 0) 0%,
          rgba(${this.rgb.r},${this.rgb.g},${this.rgb.b}, 1) 100%)`,
            };
        }
        else {
            this.gradient = {
                background: `linear-gradient(to right, rgba(${this.rgb.r},${this.rgb.g},${this.rgb.b}, 0) 0%,
          rgba(${this.rgb.r},${this.rgb.g},${this.rgb.b}, 1) 100%)`,
            };
            this.pointerLeft = this.rgb.a * 100;
        }
    }
    handleChange({ top, left, containerHeight, containerWidth, $event }) {
        let data;
        if (this.direction === 'vertical') {
            let a;
            if (top < 0) {
                a = 0;
            }
            else if (top > containerHeight) {
                a = 1;
            }
            else {
                a = Math.round(top * 100 / containerHeight) / 100;
            }
            if (this.hsl.a !== a) {
                data = {
                    h: this.hsl.h,
                    s: this.hsl.s,
                    l: this.hsl.l,
                    a,
                    source: 'rgb',
                };
            }
        }
        else {
            let a;
            if (left < 0) {
                a = 0;
            }
            else if (left > containerWidth) {
                a = 1;
            }
            else {
                a = Math.round(left * 100 / containerWidth) / 100;
            }
            if (this.hsl.a !== a) {
                data = {
                    h: this.hsl.h,
                    s: this.hsl.s,
                    l: this.hsl.l,
                    a,
                    source: 'rgb',
                };
            }
        }
        if (!data) {
            return null;
        }
        this.onChange.emit({ data, $event });
    }
};
AlphaComponent.ɵfac = function AlphaComponent_Factory(t) { return new (t || AlphaComponent)(); };
AlphaComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AlphaComponent, selectors: [["color-alpha"]], inputs: { direction: "direction", hsl: "hsl", rgb: "rgb", pointer: "pointer", shadow: "shadow", radius: "radius" }, outputs: { onChange: "onChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 7, vars: 15, consts: [[1, "alpha"], [1, "alpha-checkboard"], [1, "alpha-gradient", 3, "ngStyle"], ["ngx-color-coordinates", "", 3, "coordinatesChange"], [1, "alpha-pointer"], [1, "alpha-slider", 3, "ngStyle"]], template: function AlphaComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵelement(2, "color-checkboard");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(3, "div", 2);
        ɵngcc0.ɵɵelementStart(4, "div", 3);
        ɵngcc0.ɵɵlistener("coordinatesChange", function AlphaComponent_Template_div_coordinatesChange_4_listener($event) { return ctx.handleChange($event); });
        ɵngcc0.ɵɵelementStart(5, "div", 4);
        ɵngcc0.ɵɵelement(6, "div", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("border-radius", ctx.radius);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵstyleProp("box-shadow", ctx.shadow)("border-radius", ctx.radius);
        ɵngcc0.ɵɵproperty("ngStyle", ctx.gradient);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassMapInterpolate1("alpha-container color-alpha-", ctx.direction, "");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("left", ctx.pointerLeft, "%")("top", ctx.pointerTop, "%");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngStyle", ctx.pointer);
    } }, directives: [CheckboardComponent, ɵngcc1.NgStyle, CoordinatesDirective], styles: [".alpha[_ngcontent-%COMP%] {\n      position: absolute;\n      top: 0;\n      bottom: 0;\n      left: 0;\n      right: 0;\n    }\n    .alpha-checkboard[_ngcontent-%COMP%] {\n      position: absolute;\n      top: 0;\n      bottom: 0;\n      left: 0;\n      right: 0;\n      overflow: hidden;\n    }\n    .alpha-gradient[_ngcontent-%COMP%] {\n      position: absolute;\n      top: 0;\n      bottom: 0;\n      left: 0;\n      right: 0;\n    }\n    .alpha-container[_ngcontent-%COMP%] {\n      position: relative;\n      height: 100%;\n      margin: 0 3px;\n    }\n    .alpha-pointer[_ngcontent-%COMP%] {\n      position: absolute;\n    }\n    .alpha-slider[_ngcontent-%COMP%] {\n      width: 4px;\n      border-radius: 1px;\n      height: 8px;\n      box-shadow: 0 0 2px rgba(0, 0, 0, .6);\n      background: #fff;\n      margin-top: 1px;\n      transform: translateX(-2px);\n    },"], changeDetection: 0 });
__decorate([
    Input()
], AlphaComponent.prototype, "hsl", void 0);
__decorate([
    Input()
], AlphaComponent.prototype, "rgb", void 0);
__decorate([
    Input()
], AlphaComponent.prototype, "pointer", void 0);
__decorate([
    Input()
], AlphaComponent.prototype, "shadow", void 0);
__decorate([
    Input()
], AlphaComponent.prototype, "radius", void 0);
__decorate([
    Input()
], AlphaComponent.prototype, "direction", void 0);
__decorate([
    Output()
], AlphaComponent.prototype, "onChange", void 0);
let AlphaModule = class AlphaModule {
};
AlphaModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: AlphaModule });
AlphaModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function AlphaModule_Factory(t) { return new (t || AlphaModule)(); }, imports: [[CommonModule, CheckboardModule, CoordinatesModule]] });

function simpleCheckForValidColor(data) {
    const keysToCheck = ['r', 'g', 'b', 'a', 'h', 's', 'l', 'v'];
    let checked = 0;
    let passed = 0;
    keysToCheck.forEach(letter => {
        if (!data[letter]) {
            return;
        }
        checked += 1;
        if (!isNaN(data[letter])) {
            passed += 1;
        }
        if (letter === 's' || letter === 'l') {
            const percentPatt = /^\d+%$/;
            if (percentPatt.test(data[letter])) {
                passed += 1;
            }
        }
    });
    return checked === passed ? data : false;
}
function toState(data, oldHue) {
    const color = data.hex ? new TinyColor(data.hex) : new TinyColor(data);
    const hsl = color.toHsl();
    const hsv = color.toHsv();
    const rgb = color.toRgb();
    const hex = color.toHex();
    if (hsl.s === 0) {
        hsl.h = oldHue || 0;
        hsv.h = oldHue || 0;
    }
    const transparent = hex === '000000' && rgb.a === 0;
    return {
        hsl,
        hex: transparent ? 'transparent' : color.toHexString(),
        rgb,
        hsv,
        oldHue: data.h || oldHue || hsl.h,
        source: data.source,
    };
}
function isValidHex(hex) {
    return new TinyColor(hex).isValid;
}
function getContrastingColor(data) {
    if (!data) {
        return '#fff';
    }
    const col = toState(data);
    if (col.hex === 'transparent') {
        return 'rgba(0,0,0,0.4)';
    }
    const yiq = (col.rgb.r * 299 + col.rgb.g * 587 + col.rgb.b * 114) / 1000;
    return yiq >= 128 ? '#000' : '#fff';
}

let ColorWrap = class ColorWrap {
    constructor() {
        this.color = {
            h: 250,
            s: 0.5,
            l: 0.2,
            a: 1,
        };
        this.onChange = new EventEmitter();
        this.onChangeComplete = new EventEmitter();
        this.onSwatchHover = new EventEmitter();
    }
    ngOnInit() {
        this.changes = this.onChange
            .pipe(debounceTime(100))
            .subscribe(x => this.onChangeComplete.emit(x));
        this.setState(toState(this.color, 0));
        this.currentColor = this.hex;
    }
    ngOnChanges() {
        this.setState(toState(this.color, this.oldHue));
    }
    ngOnDestroy() {
        this.changes.unsubscribe();
    }
    setState(data) {
        this.oldHue = data.oldHue;
        this.hsl = data.hsl;
        this.hsv = data.hsv;
        this.rgb = data.rgb;
        this.hex = data.hex;
        this.source = data.source;
        this.afterValidChange();
    }
    handleChange(data, $event) {
        const isValidColor = simpleCheckForValidColor(data);
        if (isValidColor) {
            const color = toState(data, data.h || this.oldHue);
            this.setState(color);
            this.onChange.emit({ color, $event });
            this.afterValidChange();
        }
    }
    /** hook for components after a complete change */
    afterValidChange() { }
    handleSwatchHover(data, $event) {
        const isValidColor = simpleCheckForValidColor(data);
        if (isValidColor) {
            const color = toState(data, data.h || this.oldHue);
            this.setState(color);
            this.onSwatchHover.emit({ color, $event });
        }
    }
};
ColorWrap.ɵfac = function ColorWrap_Factory(t) { return new (t || ColorWrap)(); };
ColorWrap.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ColorWrap, selectors: [["color-wrap"]], inputs: { color: "color", className: "className" }, outputs: { onChange: "onChange", onChangeComplete: "onChangeComplete", onSwatchHover: "onSwatchHover" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 0, vars: 0, template: function ColorWrap_Template(rf, ctx) { }, encapsulation: 2 });
__decorate([
    Input()
], ColorWrap.prototype, "className", void 0);
__decorate([
    Input()
], ColorWrap.prototype, "color", void 0);
__decorate([
    Output()
], ColorWrap.prototype, "onChange", void 0);
__decorate([
    Output()
], ColorWrap.prototype, "onChangeComplete", void 0);
__decorate([
    Output()
], ColorWrap.prototype, "onSwatchHover", void 0);
let ColorWrapModule = class ColorWrapModule {
};
ColorWrapModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ColorWrapModule });
ColorWrapModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ColorWrapModule_Factory(t) { return new (t || ColorWrapModule)(); }, imports: [[CommonModule]] });

let EditableInputComponent = class EditableInputComponent {
    constructor() {
        this.placeholder = '';
        this.onChange = new EventEmitter();
        this.focus = false;
    }
    ngOnInit() {
        this.wrapStyle = this.style && this.style.wrap ? this.style.wrap : {};
        this.inputStyle = this.style && this.style.input ? this.style.input : {};
        this.labelStyle = this.style && this.style.label ? this.style.label : {};
        if (this.dragLabel) {
            this.labelStyle.cursor = 'ew-resize';
        }
    }
    handleFocus($event) {
        this.focus = true;
    }
    handleFocusOut($event) {
        this.focus = false;
        this.currentValue = this.blurValue;
    }
    handleKeydown($event) {
        // In case `e.target.value` is a percentage remove the `%` character
        // and update accordingly with a percentage
        // https://github.com/casesandberg/react-color/issues/383
        const stringValue = String($event.target.value);
        const isPercentage = stringValue.indexOf('%') > -1;
        const num = Number(stringValue.replace(/%/g, ''));
        if (!isNaN(num)) {
            const amount = this.arrowOffset || 1;
            // Up
            if ($event.keyCode === 38) {
                if (this.label) {
                    this.onChange.emit({
                        data: { [this.label]: num + amount },
                        $event,
                    });
                }
                else {
                    this.onChange.emit({ data: num + amount, $event });
                }
                if (isPercentage) {
                    this.currentValue = `${num + amount}%`;
                }
                else {
                    this.currentValue = num + amount;
                }
            }
            // Down
            if ($event.keyCode === 40) {
                if (this.label) {
                    this.onChange.emit({
                        data: { [this.label]: num - amount },
                        $event,
                    });
                }
                else {
                    this.onChange.emit({ data: num - amount, $event });
                }
                if (isPercentage) {
                    this.currentValue = `${num - amount}%`;
                }
                else {
                    this.currentValue = num - amount;
                }
            }
        }
    }
    handleKeyup($event) {
        if ($event.keyCode === 40 || $event.keyCode === 38) {
            return;
        }
        if (this.label) {
            this.onChange.emit({
                data: { [this.label]: $event.target.value },
                $event,
            });
        }
        else {
            this.onChange.emit({ data: $event.target.value, $event });
        }
    }
    ngOnChanges() {
        if (!this.focus) {
            this.currentValue = String(this.value).toUpperCase();
            this.blurValue = String(this.value).toUpperCase();
        }
        else {
            this.blurValue = String(this.value).toUpperCase();
        }
    }
    ngOnDestroy() {
        this.unsubscribe();
    }
    subscribe() {
        this.mousemove = fromEvent(document, 'mousemove').subscribe((ev) => this.handleDrag(ev));
        this.mouseup = fromEvent(document, 'mouseup').subscribe(() => this.unsubscribe());
    }
    unsubscribe() {
        if (this.mousemove) {
            this.mousemove.unsubscribe();
        }
        if (this.mouseup) {
            this.mouseup.unsubscribe();
        }
    }
    handleMousedown($event) {
        if (this.dragLabel) {
            $event.preventDefault();
            this.handleDrag($event);
            this.subscribe();
        }
    }
    handleDrag($event) {
        if (this.dragLabel) {
            const newValue = Math.round(this.value + $event.movementX);
            if (newValue >= 0 && newValue <= this.dragMax) {
                this.onChange.emit({ data: { [this.label]: newValue }, $event });
            }
        }
    }
};
EditableInputComponent.ɵfac = function EditableInputComponent_Factory(t) { return new (t || EditableInputComponent)(); };
EditableInputComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: EditableInputComponent, selectors: [["color-editable-input"]], inputs: { placeholder: "placeholder", style: "style", label: "label", value: "value", arrowOffset: "arrowOffset", dragLabel: "dragLabel", dragMax: "dragMax" }, outputs: { onChange: "onChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 3, vars: 5, consts: [[1, "wrap", 3, "ngStyle"], ["spellCheck", "false", 3, "ngStyle", "value", "placeholder", "keydown", "keyup", "focus", "focusout"], [3, "ngStyle", "mousedown", 4, "ngIf"], [3, "ngStyle", "mousedown"]], template: function EditableInputComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "input", 1);
        ɵngcc0.ɵɵlistener("keydown", function EditableInputComponent_Template_input_keydown_1_listener($event) { return ctx.handleKeydown($event); })("keyup", function EditableInputComponent_Template_input_keyup_1_listener($event) { return ctx.handleKeyup($event); })("focus", function EditableInputComponent_Template_input_focus_1_listener($event) { return ctx.handleFocus($event); })("focusout", function EditableInputComponent_Template_input_focusout_1_listener($event) { return ctx.handleFocusOut($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(2, EditableInputComponent_span_2_Template, 2, 2, "span", 2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngStyle", ctx.wrapStyle);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngStyle", ctx.inputStyle)("value", ctx.currentValue)("placeholder", ctx.placeholder);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.label);
    } }, directives: [ɵngcc1.NgStyle, ɵngcc1.NgIf], styles: ["[_nghost-%COMP%] {\n      display: flex;\n    }\n    .wrap[_ngcontent-%COMP%] {\n      position: relative;\n    }"], changeDetection: 0 });
__decorate([
    Input()
], EditableInputComponent.prototype, "style", void 0);
__decorate([
    Input()
], EditableInputComponent.prototype, "label", void 0);
__decorate([
    Input()
], EditableInputComponent.prototype, "value", void 0);
__decorate([
    Input()
], EditableInputComponent.prototype, "arrowOffset", void 0);
__decorate([
    Input()
], EditableInputComponent.prototype, "dragLabel", void 0);
__decorate([
    Input()
], EditableInputComponent.prototype, "dragMax", void 0);
__decorate([
    Input()
], EditableInputComponent.prototype, "placeholder", void 0);
__decorate([
    Output()
], EditableInputComponent.prototype, "onChange", void 0);
let EditableInputModule = class EditableInputModule {
};
EditableInputModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: EditableInputModule });
EditableInputModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function EditableInputModule_Factory(t) { return new (t || EditableInputModule)(); }, imports: [[CommonModule]] });

let HueComponent = class HueComponent {
    constructor() {
        this.hidePointer = false;
        this.direction = 'horizontal';
        this.onChange = new EventEmitter();
        this.left = '0px';
        this.top = '';
    }
    ngOnChanges() {
        if (this.direction === 'horizontal') {
            this.left = `${this.hsl.h * 100 / 360}%`;
        }
        else {
            this.top = `${-(this.hsl.h * 100 / 360) + 100}%`;
        }
    }
    handleChange({ top, left, containerHeight, containerWidth, $event }) {
        let data;
        if (this.direction === 'vertical') {
            let h;
            if (top < 0) {
                h = 359;
            }
            else if (top > containerHeight) {
                h = 0;
            }
            else {
                const percent = -(top * 100 / containerHeight) + 100;
                h = 360 * percent / 100;
            }
            if (this.hsl.h !== h) {
                data = {
                    h,
                    s: this.hsl.s,
                    l: this.hsl.l,
                    a: this.hsl.a,
                    source: 'rgb',
                };
            }
        }
        else {
            let h;
            if (left < 0) {
                h = 0;
            }
            else if (left > containerWidth) {
                h = 359;
            }
            else {
                const percent = left * 100 / containerWidth;
                h = 360 * percent / 100;
            }
            if (this.hsl.h !== h) {
                data = {
                    h,
                    s: this.hsl.s,
                    l: this.hsl.l,
                    a: this.hsl.a,
                    source: 'rgb',
                };
            }
        }
        if (!data) {
            return null;
        }
        this.onChange.emit({ data, $event });
    }
};
HueComponent.ɵfac = function HueComponent_Factory(t) { return new (t || HueComponent)(); };
HueComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: HueComponent, selectors: [["color-hue"]], inputs: { hidePointer: "hidePointer", direction: "direction", hsl: "hsl", pointer: "pointer", radius: "radius", shadow: "shadow" }, outputs: { onChange: "onChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 3, vars: 8, consts: [["ngx-color-coordinates", "", 1, "color-hue-container", 3, "coordinatesChange"], ["class", "color-hue-pointer", 3, "left", "top", 4, "ngIf"], [1, "color-hue-pointer"], [1, "color-hue-slider", 3, "ngStyle"]], template: function HueComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div");
        ɵngcc0.ɵɵelementStart(1, "div", 0);
        ɵngcc0.ɵɵlistener("coordinatesChange", function HueComponent_Template_div_coordinatesChange_1_listener($event) { return ctx.handleChange($event); });
        ɵngcc0.ɵɵtemplate(2, HueComponent_div_2_Template, 2, 5, "div", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassMapInterpolate1("color-hue color-hue-", ctx.direction, "");
        ɵngcc0.ɵɵstyleProp("border-radius", ctx.radius, "px")("box-shadow", ctx.shadow);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.hidePointer);
    } }, directives: [CoordinatesDirective, ɵngcc1.NgIf, ɵngcc1.NgStyle], styles: [".color-hue[_ngcontent-%COMP%] {\n      position: absolute;\n      top: 0;\n      bottom: 0;\n      left: 0;\n      right: 0;\n    }\n    .color-hue-container[_ngcontent-%COMP%] {\n      margin: 0 2px;\n      position: relative;\n      height: 100%;\n    }\n    .color-hue-pointer[_ngcontent-%COMP%] {\n      position: absolute;\n    }\n    .color-hue-slider[_ngcontent-%COMP%] {\n      margin-top: 1px;\n      width: 4px;\n      border-radius: 1px;\n      height: 8px;\n      box-shadow: 0 0 2px rgba(0, 0, 0, .6);\n      background: #fff;\n      transform: translateX(-2px);\n    }\n    .color-hue-horizontal[_ngcontent-%COMP%] {\n      background: linear-gradient(to right, #f00 0%, #ff0 17%, #0f0\n        33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n    }\n    .color-hue-vertical[_ngcontent-%COMP%] {\n      background: linear-gradient(to top, #f00 0%, #ff0 17%, #0f0 33%,\n        #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n    }"], changeDetection: 0 });
__decorate([
    Input()
], HueComponent.prototype, "hsl", void 0);
__decorate([
    Input()
], HueComponent.prototype, "pointer", void 0);
__decorate([
    Input()
], HueComponent.prototype, "radius", void 0);
__decorate([
    Input()
], HueComponent.prototype, "shadow", void 0);
__decorate([
    Input()
], HueComponent.prototype, "hidePointer", void 0);
__decorate([
    Input()
], HueComponent.prototype, "direction", void 0);
__decorate([
    Output()
], HueComponent.prototype, "onChange", void 0);
let HueModule = class HueModule {
};
HueModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: HueModule });
HueModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function HueModule_Factory(t) { return new (t || HueModule)(); }, imports: [[CommonModule, CoordinatesModule]] });

let RaisedComponent = class RaisedComponent {
    constructor() {
        this.zDepth = 1;
        this.radius = 1;
        this.background = '#fff';
    }
};
RaisedComponent.ɵfac = function RaisedComponent_Factory(t) { return new (t || RaisedComponent)(); };
RaisedComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: RaisedComponent, selectors: [["color-raised"]], inputs: { zDepth: "zDepth", radius: "radius", background: "background" }, ngContentSelectors: _c0, decls: 4, vars: 5, consts: [[1, "raised-wrap"], [1, "raised-content"]], template: function RaisedComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelement(1, "div");
        ɵngcc0.ɵɵelementStart(2, "div", 1);
        ɵngcc0.ɵɵprojection(3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassMapInterpolate1("raised-bg zDepth-", ctx.zDepth, "");
        ɵngcc0.ɵɵstyleProp("background", ctx.background, ɵngcc0.ɵɵdefaultStyleSanitizer);
    } }, styles: [".raised-wrap[_ngcontent-%COMP%] {\n      position: relative;\n      display: inline-block;\n    }\n    .raised-bg[_ngcontent-%COMP%] {\n      position: absolute;\n      top: 0px;\n      right: 0px;\n      bottom: 0px;\n      left: 0px;\n    }\n    .raised-content[_ngcontent-%COMP%] {\n      position: relative;\n    }\n    .zDepth-0[_ngcontent-%COMP%] {\n      box-shadow: none;\n    }\n    .zDepth-1[_ngcontent-%COMP%] {\n      box-shadow: 0 2px 10px rgba(0,0,0,.12), 0 2px 5px rgba(0,0,0,.16);\n    }\n    .zDepth-2[_ngcontent-%COMP%] {\n      box-shadow: 0 6px 20px rgba(0,0,0,.19), 0 8px 17px rgba(0,0,0,.2);\n    }\n    .zDepth-3[_ngcontent-%COMP%] {\n      box-shadow: 0 17px 50px rgba(0,0,0,.19), 0 12px 15px rgba(0,0,0,.24);\n    }\n    .zDepth-4[_ngcontent-%COMP%] {\n      box-shadow: 0 25px 55px rgba(0,0,0,.21), 0 16px 28px rgba(0,0,0,.22);\n    }\n    .zDepth-5[_ngcontent-%COMP%] {\n      box-shadow: 0 40px 77px rgba(0,0,0,.22), 0 27px 24px rgba(0,0,0,.2);\n    }"], changeDetection: 0 });
__decorate([
    Input()
], RaisedComponent.prototype, "zDepth", void 0);
__decorate([
    Input()
], RaisedComponent.prototype, "radius", void 0);
__decorate([
    Input()
], RaisedComponent.prototype, "background", void 0);
let RaisedModule = class RaisedModule {
};
RaisedModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: RaisedModule });
RaisedModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function RaisedModule_Factory(t) { return new (t || RaisedModule)(); }, imports: [[CommonModule]] });

let SaturationComponent = class SaturationComponent {
    constructor() {
        this.onChange = new EventEmitter();
    }
    ngOnChanges() {
        this.background = `hsl(${this.hsl.h}, 100%, 50%)`;
        this.pointerTop = -(this.hsv.v * 100) + 1 + 100 + '%';
        this.pointerLeft = this.hsv.s * 100 + '%';
    }
    handleChange({ top, left, containerHeight, containerWidth, $event }) {
        if (left < 0) {
            left = 0;
        }
        else if (left > containerWidth) {
            left = containerWidth;
        }
        else if (top < 0) {
            top = 0;
        }
        else if (top > containerHeight) {
            top = containerHeight;
        }
        const saturation = left / containerWidth;
        let bright = -(top / containerHeight) + 1;
        bright = bright > 0 ? bright : 0;
        bright = bright > 1 ? 1 : bright;
        const data = {
            h: this.hsl.h,
            s: saturation,
            v: bright,
            a: this.hsl.a,
            source: 'hsva',
        };
        this.onChange.emit({ data, $event });
    }
};
SaturationComponent.ɵfac = function SaturationComponent_Factory(t) { return new (t || SaturationComponent)(); };
SaturationComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SaturationComponent, selectors: [["color-saturation"]], inputs: { hsl: "hsl", hsv: "hsv", radius: "radius", pointer: "pointer", circle: "circle" }, outputs: { onChange: "onChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 5, vars: 8, consts: [["ngx-color-coordinates", "", 1, "color-saturation", 3, "coordinatesChange"], [1, "saturation-white"], [1, "saturation-black"], [1, "saturation-pointer", 3, "ngStyle"], [1, "saturation-circle", 3, "ngStyle"]], template: function SaturationComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵlistener("coordinatesChange", function SaturationComponent_Template_div_coordinatesChange_0_listener($event) { return ctx.handleChange($event); });
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵelement(2, "div", 2);
        ɵngcc0.ɵɵelementStart(3, "div", 3);
        ɵngcc0.ɵɵelement(4, "div", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("background", ctx.background, ɵngcc0.ɵɵdefaultStyleSanitizer);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵstyleProp("top", ctx.pointerTop)("left", ctx.pointerLeft);
        ɵngcc0.ɵɵproperty("ngStyle", ctx.pointer);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngStyle", ctx.circle);
    } }, directives: [CoordinatesDirective, ɵngcc1.NgStyle], styles: [".saturation-white[_ngcontent-%COMP%] {\n      background: linear-gradient(to right, #fff, rgba(255,255,255,0));\n      position: absolute;\n      top: 0;\n      bottom: 0;\n      left: 0;\n      right: 0;\n    }\n    .saturation-black[_ngcontent-%COMP%] {\n      background: linear-gradient(to top, #000, rgba(0,0,0,0));\n      position: absolute;\n      top: 0;\n      bottom: 0;\n      left: 0;\n      right: 0;\n    }\n    .color-saturation[_ngcontent-%COMP%] {\n      position: absolute;\n      top: 0;\n      bottom: 0;\n      left: 0;\n      right: 0;\n    }\n    .saturation-pointer[_ngcontent-%COMP%] {\n      position: absolute;\n      cursor: default;\n    }\n    .saturation-circle[_ngcontent-%COMP%] {\n      width: 4px;\n      height: 4px;\n      box-shadow: 0 0 0 1.5px #fff, inset 0 0 1px 1px rgba(0,0,0,.3), 0 0 1px 2px rgba(0,0,0,.4);\n      border-radius: 50%;\n      cursor: hand;\n      transform: translate(-2px, -4px);\n    }"], changeDetection: 0 });
__decorate([
    Input()
], SaturationComponent.prototype, "hsl", void 0);
__decorate([
    Input()
], SaturationComponent.prototype, "hsv", void 0);
__decorate([
    Input()
], SaturationComponent.prototype, "radius", void 0);
__decorate([
    Input()
], SaturationComponent.prototype, "pointer", void 0);
__decorate([
    Input()
], SaturationComponent.prototype, "circle", void 0);
__decorate([
    Output()
], SaturationComponent.prototype, "onChange", void 0);
let SaturationModule = class SaturationModule {
};
SaturationModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: SaturationModule });
SaturationModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function SaturationModule_Factory(t) { return new (t || SaturationModule)(); }, imports: [[CommonModule, CoordinatesModule]] });

let SwatchComponent = class SwatchComponent {
    constructor() {
        this.style = {};
        this.focusStyle = {};
        this.onClick = new EventEmitter();
        this.onHover = new EventEmitter();
        this.divStyles = {};
        this.focusStyles = {};
        this.inFocus = false;
    }
    ngOnInit() {
        this.divStyles = Object.assign({ background: this.color, height: '100%', width: '100%', cursor: 'pointer', position: 'relative', outline: 'none' }, this.style);
    }
    currentStyles() {
        this.focusStyles = Object.assign(Object.assign({}, this.divStyles), this.focusStyle);
        return this.focus || this.inFocus ? this.focusStyles : this.divStyles;
    }
    handleFocusOut() {
        this.inFocus = false;
    }
    handleFocus() {
        this.inFocus = true;
    }
    handleHover(hex, $event) {
        this.onHover.emit({ hex, $event });
    }
    handleClick(hex, $event) {
        this.onClick.emit({ hex, $event });
    }
};
SwatchComponent.ɵfac = function SwatchComponent_Factory(t) { return new (t || SwatchComponent)(); };
SwatchComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SwatchComponent, selectors: [["color-swatch"]], inputs: { style: "style", focusStyle: "focusStyle", color: "color", focus: "focus" }, outputs: { onClick: "onClick", onHover: "onHover" }, ngContentSelectors: _c0, decls: 3, vars: 3, consts: [["tabindex", "0", 1, "swatch", 3, "ngStyle", "click", "keydown.enter", "focus", "blur", "mouseover"], ["boxShadow", "inset 0 0 0 1px rgba(0,0,0,0.1)", 4, "ngIf"], ["boxShadow", "inset 0 0 0 1px rgba(0,0,0,0.1)"]], template: function SwatchComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵlistener("click", function SwatchComponent_Template_div_click_0_listener($event) { return ctx.handleClick(ctx.color, $event); })("keydown.enter", function SwatchComponent_Template_div_keydown_enter_0_listener($event) { return ctx.handleClick(ctx.color, $event); })("focus", function SwatchComponent_Template_div_focus_0_listener() { return ctx.handleFocus(); })("blur", function SwatchComponent_Template_div_blur_0_listener() { return ctx.handleFocusOut(); })("mouseover", function SwatchComponent_Template_div_mouseover_0_listener($event) { return ctx.handleHover(ctx.color, $event); });
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵtemplate(2, SwatchComponent_color_checkboard_2_Template, 1, 0, "color-checkboard", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngStyle", ctx.currentStyles());
        ɵngcc0.ɵɵattribute("title", ctx.color);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.color === "transparent");
    } }, directives: [ɵngcc1.NgStyle, ɵngcc1.NgIf, CheckboardComponent], encapsulation: 2, changeDetection: 0 });
__decorate([
    Input()
], SwatchComponent.prototype, "color", void 0);
__decorate([
    Input()
], SwatchComponent.prototype, "style", void 0);
__decorate([
    Input()
], SwatchComponent.prototype, "focusStyle", void 0);
__decorate([
    Input()
], SwatchComponent.prototype, "focus", void 0);
__decorate([
    Output()
], SwatchComponent.prototype, "onClick", void 0);
__decorate([
    Output()
], SwatchComponent.prototype, "onHover", void 0);
let SwatchModule = class SwatchModule {
};
SwatchModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: SwatchModule });
SwatchModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function SwatchModule_Factory(t) { return new (t || SwatchModule)(); }, imports: [[CommonModule, CheckboardModule]] });

let ShadeComponent = class ShadeComponent {
    constructor() {
        this.onChange = new EventEmitter();
    }
    ngOnChanges() {
        this.gradient = {
            background: `linear-gradient(to right,
          hsl(${this.hsl.h}, 90%, 55%),
          #000)`,
        };
        const hsv = new TinyColor(this.hsl).toHsv();
        this.pointerLeft = 100 - (hsv.v * 100);
    }
    handleChange({ left, containerWidth, $event }) {
        let data;
        let v;
        if (left < 0) {
            v = 0;
        }
        else if (left > containerWidth) {
            v = 1;
        }
        else {
            v = Math.round((left * 100) / containerWidth) / 100;
        }
        const hsv = new TinyColor(this.hsl).toHsv();
        if (hsv.v !== v) {
            data = {
                h: this.hsl.h,
                s: 100,
                v: 1 - v,
                l: this.hsl.l,
                a: this.hsl.a,
                source: 'rgb',
            };
        }
        if (!data) {
            return null;
        }
        this.onChange.emit({ data, $event });
    }
};
ShadeComponent.ɵfac = function ShadeComponent_Factory(t) { return new (t || ShadeComponent)(); };
ShadeComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ShadeComponent, selectors: [["color-shade"]], inputs: { hsl: "hsl", rgb: "rgb", pointer: "pointer", shadow: "shadow", radius: "radius" }, outputs: { onChange: "onChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 5, vars: 12, consts: [[1, "shade"], [1, "shade-gradient", 3, "ngStyle"], ["ngx-color-coordinates", "", 1, "shade-container", 3, "coordinatesChange"], [1, "shade-pointer"], [1, "shade-slider", 3, "ngStyle"]], template: function ShadeComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelement(1, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "div", 2);
        ɵngcc0.ɵɵlistener("coordinatesChange", function ShadeComponent_Template_div_coordinatesChange_2_listener($event) { return ctx.handleChange($event); });
        ɵngcc0.ɵɵelementStart(3, "div", 3);
        ɵngcc0.ɵɵelement(4, "div", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("border-radius", ctx.radius);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("box-shadow", ctx.shadow)("border-radius", ctx.radius);
        ɵngcc0.ɵɵproperty("ngStyle", ctx.gradient);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("left", ctx.pointerLeft, "%")("top", ctx.pointerTop, "%");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngStyle", ctx.pointer);
    } }, directives: [ɵngcc1.NgStyle, CoordinatesDirective], styles: [".shade[_ngcontent-%COMP%] {\n      position: absolute;\n      top: 0;\n      bottom: 0;\n      left: 0;\n      right: 0;\n    }\n    .shade-gradient[_ngcontent-%COMP%] {\n      position: absolute;\n      top: 0;\n      bottom: 0;\n      left: 0;\n      right: 0;\n    }\n    .shade-container[_ngcontent-%COMP%] {\n      position: relative;\n      height: 100%;\n      margin: 0 3px;\n    }\n    .shade-pointer[_ngcontent-%COMP%] {\n      position: absolute;\n    }\n    .shade-slider[_ngcontent-%COMP%] {\n      width: 4px;\n      border-radius: 1px;\n      height: 8px;\n      box-shadow: 0 0 2px rgba(0, 0, 0, .6);\n      background: #fff;\n      margin-top: 1px;\n      transform: translateX(-2px);\n    },"], changeDetection: 0 });
__decorate([
    Input()
], ShadeComponent.prototype, "hsl", void 0);
__decorate([
    Input()
], ShadeComponent.prototype, "rgb", void 0);
__decorate([
    Input()
], ShadeComponent.prototype, "pointer", void 0);
__decorate([
    Input()
], ShadeComponent.prototype, "shadow", void 0);
__decorate([
    Input()
], ShadeComponent.prototype, "radius", void 0);
__decorate([
    Output()
], ShadeComponent.prototype, "onChange", void 0);
let ShadeModule = class ShadeModule {
};
ShadeModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ShadeModule });
ShadeModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ShadeModule_Factory(t) { return new (t || ShadeModule)(); }, imports: [[CommonModule, CoordinatesModule]] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CheckboardComponent, [{
        type: Component,
        args: [{
                selector: 'color-checkboard',
                template: `<div class="grid" [ngStyle]="gridStyles"></div>`,
                preserveWhitespaces: false,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [`
  .grid {
    top: 0px;
    right: 0px;
    bottom: 0px;
    left: 0px;
    position: absolute;
  }
  `]
            }]
    }], function () { return []; }, { white: [{
            type: Input
        }], size: [{
            type: Input
        }], grey: [{
            type: Input
        }], boxShadow: [{
            type: Input
        }], borderRadius: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(CheckboardModule, { declarations: function () { return [CheckboardComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [CheckboardComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CheckboardModule, [{
        type: NgModule,
        args: [{
                declarations: [CheckboardComponent],
                exports: [CheckboardComponent],
                imports: [CommonModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CoordinatesDirective, [{
        type: Directive,
        args: [{ selector: '[ngx-color-coordinates]' }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { coordinatesChange: [{
            type: Output
        }], mousemove: [{
            type: HostListener,
            args: ['window:mousemove', ['$event', '$event.pageX', '$event.pageY']]
        }, {
            type: HostListener,
            args: ['window:touchmove', [
                    '$event',
                    '$event.touches[0].clientX',
                    '$event.touches[0].clientY',
                    'true',
                ]]
        }], mouseup: [{
            type: HostListener,
            args: ['window:mouseup']
        }, {
            type: HostListener,
            args: ['window:touchend']
        }], mousedown: [{
            type: HostListener,
            args: ['mousedown', ['$event', '$event.pageX', '$event.pageY']]
        }, {
            type: HostListener,
            args: ['touchstart', [
                    '$event',
                    '$event.touches[0].clientX',
                    '$event.touches[0].clientY',
                    'true',
                ]]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(CoordinatesModule, { declarations: [CoordinatesDirective], exports: [CoordinatesDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CoordinatesModule, [{
        type: NgModule,
        args: [{
                declarations: [CoordinatesDirective],
                exports: [CoordinatesDirective]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AlphaComponent, [{
        type: Component,
        args: [{
                selector: 'color-alpha',
                template: `
  <div class="alpha" [style.border-radius]="radius">
    <div class="alpha-checkboard">
      <color-checkboard></color-checkboard>
    </div>
    <div class="alpha-gradient" [ngStyle]="gradient" [style.box-shadow]="shadow" [style.border-radius]="radius"></div>
    <div ngx-color-coordinates (coordinatesChange)="handleChange($event)" class="alpha-container color-alpha-{{direction}}">
      <div class="alpha-pointer" [style.left.%]="pointerLeft" [style.top.%]="pointerTop">
        <div class="alpha-slider" [ngStyle]="pointer"></div>
      </div>
    </div>
  </div>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                styles: [`
    .alpha {
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
    }
    .alpha-checkboard {
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
      overflow: hidden;
    }
    .alpha-gradient {
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
    }
    .alpha-container {
      position: relative;
      height: 100%;
      margin: 0 3px;
    }
    .alpha-pointer {
      position: absolute;
    }
    .alpha-slider {
      width: 4px;
      border-radius: 1px;
      height: 8px;
      box-shadow: 0 0 2px rgba(0, 0, 0, .6);
      background: #fff;
      margin-top: 1px;
      transform: translateX(-2px);
    },
  `]
            }]
    }], function () { return []; }, { direction: [{
            type: Input
        }], onChange: [{
            type: Output
        }], hsl: [{
            type: Input
        }], rgb: [{
            type: Input
        }], pointer: [{
            type: Input
        }], shadow: [{
            type: Input
        }], radius: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(AlphaModule, { declarations: function () { return [AlphaComponent]; }, imports: function () { return [CommonModule,
        CheckboardModule,
        CoordinatesModule]; }, exports: function () { return [AlphaComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AlphaModule, [{
        type: NgModule,
        args: [{
                declarations: [AlphaComponent],
                exports: [AlphaComponent],
                imports: [CommonModule, CheckboardModule, CoordinatesModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ColorWrap, [{
        type: Component,
        args: [{
                // create seletor base for test override property
                selector: 'color-wrap',
                template: ``
            }]
    }], function () { return []; }, { color: [{
            type: Input
        }], onChange: [{
            type: Output
        }], onChangeComplete: [{
            type: Output
        }], onSwatchHover: [{
            type: Output
        }], className: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ColorWrapModule, { declarations: function () { return [ColorWrap]; }, imports: function () { return [CommonModule]; }, exports: function () { return [ColorWrap]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ColorWrapModule, [{
        type: NgModule,
        args: [{
                declarations: [ColorWrap],
                exports: [ColorWrap],
                imports: [CommonModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(EditableInputComponent, [{
        type: Component,
        args: [{
                selector: 'color-editable-input',
                template: `
  <div class="wrap" [ngStyle]="wrapStyle">
    <input [ngStyle]="inputStyle" spellCheck="false"
      [value]="currentValue" [placeholder]="placeholder"
      (keydown)="handleKeydown($event)" (keyup)="handleKeyup($event)"
      (focus)="handleFocus($event)" (focusout)="handleFocusOut($event)" />
    <span *ngIf="label" [ngStyle]="labelStyle" (mousedown)="handleMousedown($event)">
      {{ label }}
    </span>
  </div>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [`
    :host {
      display: flex;
    }
    .wrap {
      position: relative;
    }
  `]
            }]
    }], function () { return []; }, { placeholder: [{
            type: Input
        }], onChange: [{
            type: Output
        }], style: [{
            type: Input
        }], label: [{
            type: Input
        }], value: [{
            type: Input
        }], arrowOffset: [{
            type: Input
        }], dragLabel: [{
            type: Input
        }], dragMax: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(EditableInputModule, { declarations: function () { return [EditableInputComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [EditableInputComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(EditableInputModule, [{
        type: NgModule,
        args: [{
                declarations: [EditableInputComponent],
                exports: [EditableInputComponent],
                imports: [CommonModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(HueComponent, [{
        type: Component,
        args: [{
                selector: 'color-hue',
                template: `
  <div class="color-hue color-hue-{{direction}}" [style.border-radius.px]="radius" [style.box-shadow]="shadow">
    <div ngx-color-coordinates (coordinatesChange)="handleChange($event)" class="color-hue-container">
      <div class="color-hue-pointer" [style.left]="left" [style.top]="top" *ngIf="!hidePointer">
        <div class="color-hue-slider" [ngStyle]="pointer"></div>
      </div>
    </div>
  </div>
  `,
                preserveWhitespaces: false,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [`
    .color-hue {
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
    }
    .color-hue-container {
      margin: 0 2px;
      position: relative;
      height: 100%;
    }
    .color-hue-pointer {
      position: absolute;
    }
    .color-hue-slider {
      margin-top: 1px;
      width: 4px;
      border-radius: 1px;
      height: 8px;
      box-shadow: 0 0 2px rgba(0, 0, 0, .6);
      background: #fff;
      transform: translateX(-2px);
    }
    .color-hue-horizontal {
      background: linear-gradient(to right, #f00 0%, #ff0 17%, #0f0
        33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);
    }
    .color-hue-vertical {
      background: linear-gradient(to top, #f00 0%, #ff0 17%, #0f0 33%,
        #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);
    }
  `]
            }]
    }], function () { return []; }, { hidePointer: [{
            type: Input
        }], direction: [{
            type: Input
        }], onChange: [{
            type: Output
        }], hsl: [{
            type: Input
        }], pointer: [{
            type: Input
        }], radius: [{
            type: Input
        }], shadow: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(HueModule, { declarations: function () { return [HueComponent]; }, imports: function () { return [CommonModule,
        CoordinatesModule]; }, exports: function () { return [HueComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(HueModule, [{
        type: NgModule,
        args: [{
                declarations: [HueComponent],
                exports: [HueComponent],
                imports: [CommonModule, CoordinatesModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(RaisedComponent, [{
        type: Component,
        args: [{
                selector: 'color-raised',
                template: `
  <div class="raised-wrap">
    <div class="raised-bg zDepth-{{zDepth}}" [style.background]="background"></div>
    <div class="raised-content">
      <ng-content></ng-content>
    </div>
  </div>
  `,
                preserveWhitespaces: false,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [`
    .raised-wrap {
      position: relative;
      display: inline-block;
    }
    .raised-bg {
      position: absolute;
      top: 0px;
      right: 0px;
      bottom: 0px;
      left: 0px;
    }
    .raised-content {
      position: relative;
    }
    .zDepth-0 {
      box-shadow: none;
    }
    .zDepth-1 {
      box-shadow: 0 2px 10px rgba(0,0,0,.12), 0 2px 5px rgba(0,0,0,.16);
    }
    .zDepth-2 {
      box-shadow: 0 6px 20px rgba(0,0,0,.19), 0 8px 17px rgba(0,0,0,.2);
    }
    .zDepth-3 {
      box-shadow: 0 17px 50px rgba(0,0,0,.19), 0 12px 15px rgba(0,0,0,.24);
    }
    .zDepth-4 {
      box-shadow: 0 25px 55px rgba(0,0,0,.21), 0 16px 28px rgba(0,0,0,.22);
    }
    .zDepth-5 {
      box-shadow: 0 40px 77px rgba(0,0,0,.22), 0 27px 24px rgba(0,0,0,.2);
    }
  `]
            }]
    }], function () { return []; }, { zDepth: [{
            type: Input
        }], radius: [{
            type: Input
        }], background: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(RaisedModule, { declarations: function () { return [RaisedComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [RaisedComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(RaisedModule, [{
        type: NgModule,
        args: [{
                declarations: [RaisedComponent],
                exports: [RaisedComponent],
                imports: [CommonModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SaturationComponent, [{
        type: Component,
        args: [{
                selector: 'color-saturation',
                template: `
  <div class="color-saturation" ngx-color-coordinates (coordinatesChange)="handleChange($event)" [style.background]="background">
    <div class="saturation-white">
      <div class="saturation-black"></div>
      <div class="saturation-pointer" [ngStyle]="pointer" [style.top]="pointerTop" [style.left]="pointerLeft">
        <div class="saturation-circle" [ngStyle]="circle"></div>
      </div>
    </div>
  </div>
  `,
                preserveWhitespaces: false,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [`
    .saturation-white {
      background: linear-gradient(to right, #fff, rgba(255,255,255,0));
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
    }
    .saturation-black {
      background: linear-gradient(to top, #000, rgba(0,0,0,0));
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
    }
    .color-saturation {
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
    }
    .saturation-pointer {
      position: absolute;
      cursor: default;
    }
    .saturation-circle {
      width: 4px;
      height: 4px;
      box-shadow: 0 0 0 1.5px #fff, inset 0 0 1px 1px rgba(0,0,0,.3), 0 0 1px 2px rgba(0,0,0,.4);
      border-radius: 50%;
      cursor: hand;
      transform: translate(-2px, -4px);
    }
  `]
            }]
    }], function () { return []; }, { onChange: [{
            type: Output
        }], hsl: [{
            type: Input
        }], hsv: [{
            type: Input
        }], radius: [{
            type: Input
        }], pointer: [{
            type: Input
        }], circle: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(SaturationModule, { declarations: function () { return [SaturationComponent]; }, imports: function () { return [CommonModule,
        CoordinatesModule]; }, exports: function () { return [SaturationComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SaturationModule, [{
        type: NgModule,
        args: [{
                declarations: [SaturationComponent],
                exports: [SaturationComponent],
                imports: [CommonModule, CoordinatesModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SwatchComponent, [{
        type: Component,
        args: [{
                selector: 'color-swatch',
                template: `
    <div
      class="swatch"
      [ngStyle]="currentStyles()"
      [attr.title]="color"
      (click)="handleClick(color, $event)"
      (keydown.enter)="handleClick(color, $event)"
      (focus)="handleFocus()"
      (blur)="handleFocusOut()"
      (mouseover)="handleHover(color, $event)"
      tabindex="0"
    >
      <ng-content></ng-content>
      <color-checkboard
        *ngIf="color === 'transparent'"
        boxShadow="inset 0 0 0 1px rgba(0,0,0,0.1)"
      ></color-checkboard>
    </div>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { style: [{
            type: Input
        }], focusStyle: [{
            type: Input
        }], onClick: [{
            type: Output
        }], onHover: [{
            type: Output
        }], color: [{
            type: Input
        }], focus: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(SwatchModule, { declarations: function () { return [SwatchComponent]; }, imports: function () { return [CommonModule,
        CheckboardModule]; }, exports: function () { return [SwatchComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SwatchModule, [{
        type: NgModule,
        args: [{
                declarations: [SwatchComponent],
                exports: [SwatchComponent],
                imports: [CommonModule, CheckboardModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ShadeComponent, [{
        type: Component,
        args: [{
                selector: 'color-shade',
                template: `
    <div class="shade" [style.border-radius]="radius">
      <div
        class="shade-gradient"
        [ngStyle]="gradient"
        [style.box-shadow]="shadow"
        [style.border-radius]="radius"
      ></div>
      <div
        ngx-color-coordinates
        (coordinatesChange)="handleChange($event)"
        class="shade-container"
      >
        <div
          class="shade-pointer"
          [style.left.%]="pointerLeft"
          [style.top.%]="pointerTop"
        >
          <div class="shade-slider" [ngStyle]="pointer"></div>
        </div>
      </div>
    </div>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                styles: [`
    .shade {
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
    }
    .shade-gradient {
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
    }
    .shade-container {
      position: relative;
      height: 100%;
      margin: 0 3px;
    }
    .shade-pointer {
      position: absolute;
    }
    .shade-slider {
      width: 4px;
      border-radius: 1px;
      height: 8px;
      box-shadow: 0 0 2px rgba(0, 0, 0, .6);
      background: #fff;
      margin-top: 1px;
      transform: translateX(-2px);
    },
  `]
            }]
    }], function () { return []; }, { onChange: [{
            type: Output
        }], hsl: [{
            type: Input
        }], rgb: [{
            type: Input
        }], pointer: [{
            type: Input
        }], shadow: [{
            type: Input
        }], radius: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ShadeModule, { declarations: function () { return [ShadeComponent]; }, imports: function () { return [CommonModule,
        CoordinatesModule]; }, exports: function () { return [ShadeComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ShadeModule, [{
        type: NgModule,
        args: [{
                declarations: [ShadeComponent],
                exports: [ShadeComponent],
                imports: [CommonModule, CoordinatesModule]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { AlphaComponent, AlphaModule, CheckboardComponent, CheckboardModule, ColorWrap, ColorWrapModule, CoordinatesDirective, CoordinatesModule, EditableInputComponent, EditableInputModule, HueComponent, HueModule, RaisedComponent, RaisedModule, SaturationComponent, SaturationModule, ShadeComponent, ShadeModule, SwatchComponent, SwatchModule, getCheckerboard, getContrastingColor, isValidHex, render, simpleCheckForValidColor, toState };

//# sourceMappingURL=ngx-color.js.map