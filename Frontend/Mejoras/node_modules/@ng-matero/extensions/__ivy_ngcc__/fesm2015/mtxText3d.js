import { Component, ViewEncapsulation, ChangeDetectionStrategy, ContentChild, TemplateRef, Input, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * Generated from: text3d.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

const _c0 = function (a0, a1) { return { "z-index": a0, "transform": a1 }; };
function MtxText3dComponent_span_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 1);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementContainer(2, 2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const i_r1 = ctx.$implicit;
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngStyle", ɵngcc0.ɵɵpureFunction2(3, _c0, 0 - i_r1, "translate3d(0, 0," + (0 - i_r1) + "px)"));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r0.text, " ");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r0.template);
} }
class MtxText3dComponent {
    constructor() {
        this.text = '';
        this.depth = 20;
        this.rotateX = 60;
        this.rotateY = 0;
        this.rotateZ = 0;
    }
    /**
     * @return {?}
     */
    get transform() {
        return `rotateX(${this.rotateX}deg) rotateY(${this.rotateY}deg) rotateZ(${this.rotateZ}deg)`;
    }
    /**
     * @return {?}
     */
    get depthArr() {
        /** @type {?} */
        const tmpArr = [];
        for (let i = 1; i <= this.depth; i++) {
            tmpArr.push(i);
        }
        return tmpArr;
    }
}
MtxText3dComponent.ɵfac = function MtxText3dComponent_Factory(t) { return new (t || MtxText3dComponent)(); };
MtxText3dComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MtxText3dComponent, selectors: [["mtx-text3d"]], contentQueries: function MtxText3dComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, TemplateRef, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.template = _t.first);
    } }, hostAttrs: [1, "mtx-text3d"], hostVars: 2, hostBindings: function MtxText3dComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("transform", ctx.transform);
    } }, inputs: { text: "text", depth: "depth", rotateX: "rotateX", rotateY: "rotateY", rotateZ: "rotateZ" }, exportAs: ["mtxText3d"], decls: 1, vars: 1, consts: [["class", "mtx-text3d-layer", 3, "ngStyle", 4, "ngFor", "ngForOf"], [1, "mtx-text3d-layer", 3, "ngStyle"], [3, "ngTemplateOutlet"]], template: function MtxText3dComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, MtxText3dComponent_span_0_Template, 3, 6, "span", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.depthArr);
    } }, directives: [ɵngcc1.NgForOf, ɵngcc1.NgStyle, ɵngcc1.NgTemplateOutlet], styles: [".mtx-text3d{display:block;transform-style:preserve-3d;-webkit-animation:5s infinite rotate;animation:5s infinite rotate;font-weight:700}.mtx-text3d .mtx-text3d-layer{display:block;text-align:center;font-size:10rem;text-shadow:0 0 1px rgba(0,0,0,.5)}.mtx-text3d .mtx-text3d-layer:not(:first-child){position:absolute;top:0;left:0;right:0;margin:auto;transform-style:preserve-3d;color:#fbfbfb;text-shadow:0 0 20px rgba(124,124,124,.4)}.mtx-text3d .mtx-text3d-layer:first-child{color:#171717}"], encapsulation: 2, changeDetection: 0 });
/** @nocollapse */
MtxText3dComponent.ctorParameters = () => [];
MtxText3dComponent.propDecorators = {
    template: [{ type: ContentChild, args: [TemplateRef, { static: false },] }],
    text: [{ type: Input }],
    depth: [{ type: Input }],
    rotateX: [{ type: Input }],
    rotateY: [{ type: Input }],
    rotateZ: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MtxText3dComponent, [{
        type: Component,
        args: [{
                selector: 'mtx-text3d',
                exportAs: 'mtxText3d',
                host: {
                    'class': 'mtx-text3d',
                    '[style.transform]': 'transform'
                },
                template: "<span class=\"mtx-text3d-layer\" *ngFor=\"let i of depthArr\"\n      [ngStyle]=\"{'z-index': -i, 'transform': 'translate3d(0, 0,'+ -i + 'px)'}\">\n  {{text}}\n  <ng-container [ngTemplateOutlet]=\"template\"></ng-container>\n</span>\n",
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".mtx-text3d{display:block;transform-style:preserve-3d;-webkit-animation:5s infinite rotate;animation:5s infinite rotate;font-weight:700}.mtx-text3d .mtx-text3d-layer{display:block;text-align:center;font-size:10rem;text-shadow:0 0 1px rgba(0,0,0,.5)}.mtx-text3d .mtx-text3d-layer:not(:first-child){position:absolute;top:0;left:0;right:0;margin:auto;transform-style:preserve-3d;color:#fbfbfb;text-shadow:0 0 20px rgba(124,124,124,.4)}.mtx-text3d .mtx-text3d-layer:first-child{color:#171717}"]
            }]
    }], function () { return []; }, { text: [{
            type: Input
        }], depth: [{
            type: Input
        }], rotateX: [{
            type: Input
        }], rotateY: [{
            type: Input
        }], rotateZ: [{
            type: Input
        }], template: [{
            type: ContentChild,
            args: [TemplateRef, { static: false }]
        }] }); })();
if (false) {
    /** @type {?} */
    MtxText3dComponent.prototype.template;
    /** @type {?} */
    MtxText3dComponent.prototype.text;
    /** @type {?} */
    MtxText3dComponent.prototype.depth;
    /** @type {?} */
    MtxText3dComponent.prototype.rotateX;
    /** @type {?} */
    MtxText3dComponent.prototype.rotateY;
    /** @type {?} */
    MtxText3dComponent.prototype.rotateZ;
}

/**
 * @fileoverview added by tsickle
 * Generated from: text3d.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MtxText3dModule {
}
MtxText3dModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MtxText3dModule });
MtxText3dModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MtxText3dModule_Factory(t) { return new (t || MtxText3dModule)(); }, imports: [[CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MtxText3dModule, { declarations: function () { return [MtxText3dComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [MtxText3dComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MtxText3dModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule],
                exports: [MtxText3dComponent],
                declarations: [MtxText3dComponent]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: mtxText3d.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { MtxText3dComponent, MtxText3dModule };

//# sourceMappingURL=mtxText3d.js.map