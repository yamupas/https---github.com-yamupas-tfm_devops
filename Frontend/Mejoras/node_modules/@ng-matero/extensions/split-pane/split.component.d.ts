import { ChangeDetectorRef, Renderer2, AfterViewInit, OnDestroy, ElementRef, NgZone, EventEmitter } from '@angular/core';
import { Observable } from 'rxjs';
import { MtxSplitArea, MtxSplitOutputData, MtxSplitOutputAreaSizes } from './interface';
import { MtxSplitPaneDirective } from './split-pane.directive';
/**
 * mtx-split
 *
 *
 *  PERCENT MODE ([unit]="'percent'")
 *  ___________________________________________________________________________________________
 * |       A       [g1]       B       [g2]       C       [g3]       D       [g4]       E       |
 * |-------------------------------------------------------------------------------------------|
 * |       20                 30                 20                 15                 15      | <-- [size]="x"
 * |               10px               10px               10px               10px               | <-- [gutterSize]="10"
 * |calc(20% - 8px)    calc(30% - 12px)   calc(20% - 8px)    calc(15% - 6px)    calc(15% - 6px)| <-- CSS flex-basis property (with flex-grow&shrink at 0)
 * |     152px              228px              152px              114px              114px     | <-- el.getBoundingClientRect().width
 * |___________________________________________________________________________________________|
 *                                                                                 800px         <-- el.getBoundingClientRect().width
 *  flex-basis = calc( { area.size }% - { area.size/100 * nbGutter*gutterSize }px );
 *
 *
 *  PIXEL MODE ([unit]="'pixel'")
 *  ___________________________________________________________________________________________
 * |       A       [g1]       B       [g2]       C       [g3]       D       [g4]       E       |
 * |-------------------------------------------------------------------------------------------|
 * |      100                250                 *                 150                100      | <-- [size]="y"
 * |               10px               10px               10px               10px               | <-- [gutterSize]="10"
 * |   0 0 100px          0 0 250px           1 1 auto          0 0 150px          0 0 100px   | <-- CSS flex property (flex-grow/flex-shrink/flex-basis)
 * |     100px              250px              200px              150px              100px     | <-- el.getBoundingClientRect().width
 * |___________________________________________________________________________________________|
 *                                                                                 800px         <-- el.getBoundingClientRect().width
 *
 */
import * as ɵngcc0 from '@angular/core';
export declare class MtxSplitComponent implements AfterViewInit, OnDestroy {
    private ngZone;
    private elRef;
    private cdRef;
    private renderer;
    private _direction;
    set direction(v: 'horizontal' | 'vertical');
    get direction(): 'horizontal' | 'vertical';
    private _unit;
    set unit(v: 'percent' | 'pixel');
    get unit(): 'percent' | 'pixel';
    private _gutterSize;
    set gutterSize(v: number | null);
    get gutterSize(): number;
    private _gutterStep;
    set gutterStep(v: number);
    get gutterStep(): number;
    private _restrictMove;
    set restrictMove(v: boolean);
    get restrictMove(): boolean;
    private _useTransition;
    set useTransition(v: boolean);
    get useTransition(): boolean;
    private _disabled;
    set disabled(v: boolean);
    get disabled(): boolean;
    private _dir;
    set dir(v: 'ltr' | 'rtl');
    get dir(): 'ltr' | 'rtl';
    private _gutterDblClickDuration;
    set gutterDblClickDuration(v: number);
    get gutterDblClickDuration(): number;
    dragStart: EventEmitter<MtxSplitOutputData>;
    dragEnd: EventEmitter<MtxSplitOutputData>;
    gutterClick: EventEmitter<MtxSplitOutputData>;
    gutterDblClick: EventEmitter<MtxSplitOutputData>;
    private transitionEndSubscriber;
    get transitionEnd(): Observable<MtxSplitOutputAreaSizes>;
    private dragProgressSubject;
    dragProgress$: Observable<MtxSplitOutputData>;
    private isDragging;
    private dragListeners;
    private snapshot;
    private startPoint;
    private endPoint;
    readonly displayedAreas: Array<MtxSplitArea>;
    private readonly hidedAreas;
    private gutterEls;
    constructor(ngZone: NgZone, elRef: ElementRef, cdRef: ChangeDetectorRef, renderer: Renderer2);
    ngAfterViewInit(): void;
    private getNbGutters;
    addArea(component: MtxSplitPaneDirective): void;
    removeArea(component: MtxSplitPaneDirective): void;
    updateArea(component: MtxSplitPaneDirective, resetOrders: boolean, resetSizes: boolean): void;
    showArea(component: MtxSplitPaneDirective): void;
    hideArea(comp: MtxSplitPaneDirective): void;
    getVisibleAreaSizes(): MtxSplitOutputAreaSizes;
    setVisibleAreaSizes(sizes: MtxSplitOutputAreaSizes): boolean;
    private build;
    private refreshStyleSizes;
    _clickTimeout: number | null;
    clickGutter(event: MouseEvent | TouchEvent, gutterNum: number): void;
    startDragging(event: MouseEvent | TouchEvent, gutterOrder: number, gutterNum: number): void;
    private dragEvent;
    private stopDragging;
    notify(type: 'start' | 'progress' | 'end' | 'click' | 'dblclick' | 'transitionEnd', gutterNum: number): void;
    ngOnDestroy(): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<MtxSplitComponent, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<MtxSplitComponent, "mtx-split", ["mtxSplit"], { "direction": "direction"; "unit": "unit"; "gutterSize": "gutterSize"; "gutterStep": "gutterStep"; "restrictMove": "restrictMove"; "useTransition": "useTransition"; "disabled": "disabled"; "dir": "dir"; "gutterDblClickDuration": "gutterDblClickDuration"; }, { "dragStart": "dragStart"; "dragEnd": "dragEnd"; "gutterClick": "gutterClick"; "gutterDblClick": "gutterDblClick"; "transitionEnd": "transitionEnd"; }, never, ["*"]>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3BsaXQuY29tcG9uZW50LmQudHMiLCJzb3VyY2VzIjpbInNwbGl0LmNvbXBvbmVudC5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDaGFuZ2VEZXRlY3RvclJlZiwgUmVuZGVyZXIyLCBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3ksIEVsZW1lbnRSZWYsIE5nWm9uZSwgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBNdHhTcGxpdEFyZWEsIE10eFNwbGl0T3V0cHV0RGF0YSwgTXR4U3BsaXRPdXRwdXRBcmVhU2l6ZXMgfSBmcm9tICcuL2ludGVyZmFjZSc7XG5pbXBvcnQgeyBNdHhTcGxpdFBhbmVEaXJlY3RpdmUgfSBmcm9tICcuL3NwbGl0LXBhbmUuZGlyZWN0aXZlJztcbi8qKlxuICogbXR4LXNwbGl0XG4gKlxuICpcbiAqICBQRVJDRU5UIE1PREUgKFt1bml0XT1cIidwZXJjZW50J1wiKVxuICogIF9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19cbiAqIHwgICAgICAgQSAgICAgICBbZzFdICAgICAgIEIgICAgICAgW2cyXSAgICAgICBDICAgICAgIFtnM10gICAgICAgRCAgICAgICBbZzRdICAgICAgIEUgICAgICAgfFxuICogfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gKiB8ICAgICAgIDIwICAgICAgICAgICAgICAgICAzMCAgICAgICAgICAgICAgICAgMjAgICAgICAgICAgICAgICAgIDE1ICAgICAgICAgICAgICAgICAxNSAgICAgIHwgPC0tIFtzaXplXT1cInhcIlxuICogfCAgICAgICAgICAgICAgIDEwcHggICAgICAgICAgICAgICAxMHB4ICAgICAgICAgICAgICAgMTBweCAgICAgICAgICAgICAgIDEwcHggICAgICAgICAgICAgICB8IDwtLSBbZ3V0dGVyU2l6ZV09XCIxMFwiXG4gKiB8Y2FsYygyMCUgLSA4cHgpICAgIGNhbGMoMzAlIC0gMTJweCkgICBjYWxjKDIwJSAtIDhweCkgICAgY2FsYygxNSUgLSA2cHgpICAgIGNhbGMoMTUlIC0gNnB4KXwgPC0tIENTUyBmbGV4LWJhc2lzIHByb3BlcnR5ICh3aXRoIGZsZXgtZ3JvdyZzaHJpbmsgYXQgMClcbiAqIHwgICAgIDE1MnB4ICAgICAgICAgICAgICAyMjhweCAgICAgICAgICAgICAgMTUycHggICAgICAgICAgICAgIDExNHB4ICAgICAgICAgICAgICAxMTRweCAgICAgfCA8LS0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGhcbiAqIHxfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19ffFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA4MDBweCAgICAgICAgIDwtLSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aFxuICogIGZsZXgtYmFzaXMgPSBjYWxjKCB7IGFyZWEuc2l6ZSB9JSAtIHsgYXJlYS5zaXplLzEwMCAqIG5iR3V0dGVyKmd1dHRlclNpemUgfXB4ICk7XG4gKlxuICpcbiAqICBQSVhFTCBNT0RFIChbdW5pdF09XCIncGl4ZWwnXCIpXG4gKiAgX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX1xuICogfCAgICAgICBBICAgICAgIFtnMV0gICAgICAgQiAgICAgICBbZzJdICAgICAgIEMgICAgICAgW2czXSAgICAgICBEICAgICAgIFtnNF0gICAgICAgRSAgICAgICB8XG4gKiB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAqIHwgICAgICAxMDAgICAgICAgICAgICAgICAgMjUwICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgICAgICAxNTAgICAgICAgICAgICAgICAgMTAwICAgICAgfCA8LS0gW3NpemVdPVwieVwiXG4gKiB8ICAgICAgICAgICAgICAgMTBweCAgICAgICAgICAgICAgIDEwcHggICAgICAgICAgICAgICAxMHB4ICAgICAgICAgICAgICAgMTBweCAgICAgICAgICAgICAgIHwgPC0tIFtndXR0ZXJTaXplXT1cIjEwXCJcbiAqIHwgICAwIDAgMTAwcHggICAgICAgICAgMCAwIDI1MHB4ICAgICAgICAgICAxIDEgYXV0byAgICAgICAgICAwIDAgMTUwcHggICAgICAgICAgMCAwIDEwMHB4ICAgfCA8LS0gQ1NTIGZsZXggcHJvcGVydHkgKGZsZXgtZ3Jvdy9mbGV4LXNocmluay9mbGV4LWJhc2lzKVxuICogfCAgICAgMTAwcHggICAgICAgICAgICAgIDI1MHB4ICAgICAgICAgICAgICAyMDBweCAgICAgICAgICAgICAgMTUwcHggICAgICAgICAgICAgIDEwMHB4ICAgICB8IDwtLSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aFxuICogfF9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX198XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDgwMHB4ICAgICAgICAgPC0tIGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoXG4gKlxuICovXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBNdHhTcGxpdENvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSB7XG4gICAgcHJpdmF0ZSBuZ1pvbmU7XG4gICAgcHJpdmF0ZSBlbFJlZjtcbiAgICBwcml2YXRlIGNkUmVmO1xuICAgIHByaXZhdGUgcmVuZGVyZXI7XG4gICAgcHJpdmF0ZSBfZGlyZWN0aW9uO1xuICAgIHNldCBkaXJlY3Rpb24odjogJ2hvcml6b250YWwnIHwgJ3ZlcnRpY2FsJyk7XG4gICAgZ2V0IGRpcmVjdGlvbigpOiAnaG9yaXpvbnRhbCcgfCAndmVydGljYWwnO1xuICAgIHByaXZhdGUgX3VuaXQ7XG4gICAgc2V0IHVuaXQodjogJ3BlcmNlbnQnIHwgJ3BpeGVsJyk7XG4gICAgZ2V0IHVuaXQoKTogJ3BlcmNlbnQnIHwgJ3BpeGVsJztcbiAgICBwcml2YXRlIF9ndXR0ZXJTaXplO1xuICAgIHNldCBndXR0ZXJTaXplKHY6IG51bWJlciB8IG51bGwpO1xuICAgIGdldCBndXR0ZXJTaXplKCk6IG51bWJlcjtcbiAgICBwcml2YXRlIF9ndXR0ZXJTdGVwO1xuICAgIHNldCBndXR0ZXJTdGVwKHY6IG51bWJlcik7XG4gICAgZ2V0IGd1dHRlclN0ZXAoKTogbnVtYmVyO1xuICAgIHByaXZhdGUgX3Jlc3RyaWN0TW92ZTtcbiAgICBzZXQgcmVzdHJpY3RNb3ZlKHY6IGJvb2xlYW4pO1xuICAgIGdldCByZXN0cmljdE1vdmUoKTogYm9vbGVhbjtcbiAgICBwcml2YXRlIF91c2VUcmFuc2l0aW9uO1xuICAgIHNldCB1c2VUcmFuc2l0aW9uKHY6IGJvb2xlYW4pO1xuICAgIGdldCB1c2VUcmFuc2l0aW9uKCk6IGJvb2xlYW47XG4gICAgcHJpdmF0ZSBfZGlzYWJsZWQ7XG4gICAgc2V0IGRpc2FibGVkKHY6IGJvb2xlYW4pO1xuICAgIGdldCBkaXNhYmxlZCgpOiBib29sZWFuO1xuICAgIHByaXZhdGUgX2RpcjtcbiAgICBzZXQgZGlyKHY6ICdsdHInIHwgJ3J0bCcpO1xuICAgIGdldCBkaXIoKTogJ2x0cicgfCAncnRsJztcbiAgICBwcml2YXRlIF9ndXR0ZXJEYmxDbGlja0R1cmF0aW9uO1xuICAgIHNldCBndXR0ZXJEYmxDbGlja0R1cmF0aW9uKHY6IG51bWJlcik7XG4gICAgZ2V0IGd1dHRlckRibENsaWNrRHVyYXRpb24oKTogbnVtYmVyO1xuICAgIGRyYWdTdGFydDogRXZlbnRFbWl0dGVyPE10eFNwbGl0T3V0cHV0RGF0YT47XG4gICAgZHJhZ0VuZDogRXZlbnRFbWl0dGVyPE10eFNwbGl0T3V0cHV0RGF0YT47XG4gICAgZ3V0dGVyQ2xpY2s6IEV2ZW50RW1pdHRlcjxNdHhTcGxpdE91dHB1dERhdGE+O1xuICAgIGd1dHRlckRibENsaWNrOiBFdmVudEVtaXR0ZXI8TXR4U3BsaXRPdXRwdXREYXRhPjtcbiAgICBwcml2YXRlIHRyYW5zaXRpb25FbmRTdWJzY3JpYmVyO1xuICAgIGdldCB0cmFuc2l0aW9uRW5kKCk6IE9ic2VydmFibGU8TXR4U3BsaXRPdXRwdXRBcmVhU2l6ZXM+O1xuICAgIHByaXZhdGUgZHJhZ1Byb2dyZXNzU3ViamVjdDtcbiAgICBkcmFnUHJvZ3Jlc3MkOiBPYnNlcnZhYmxlPE10eFNwbGl0T3V0cHV0RGF0YT47XG4gICAgcHJpdmF0ZSBpc0RyYWdnaW5nO1xuICAgIHByaXZhdGUgZHJhZ0xpc3RlbmVycztcbiAgICBwcml2YXRlIHNuYXBzaG90O1xuICAgIHByaXZhdGUgc3RhcnRQb2ludDtcbiAgICBwcml2YXRlIGVuZFBvaW50O1xuICAgIHJlYWRvbmx5IGRpc3BsYXllZEFyZWFzOiBBcnJheTxNdHhTcGxpdEFyZWE+O1xuICAgIHByaXZhdGUgcmVhZG9ubHkgaGlkZWRBcmVhcztcbiAgICBwcml2YXRlIGd1dHRlckVscztcbiAgICBjb25zdHJ1Y3RvcihuZ1pvbmU6IE5nWm9uZSwgZWxSZWY6IEVsZW1lbnRSZWYsIGNkUmVmOiBDaGFuZ2VEZXRlY3RvclJlZiwgcmVuZGVyZXI6IFJlbmRlcmVyMik7XG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQ7XG4gICAgcHJpdmF0ZSBnZXROYkd1dHRlcnM7XG4gICAgYWRkQXJlYShjb21wb25lbnQ6IE10eFNwbGl0UGFuZURpcmVjdGl2ZSk6IHZvaWQ7XG4gICAgcmVtb3ZlQXJlYShjb21wb25lbnQ6IE10eFNwbGl0UGFuZURpcmVjdGl2ZSk6IHZvaWQ7XG4gICAgdXBkYXRlQXJlYShjb21wb25lbnQ6IE10eFNwbGl0UGFuZURpcmVjdGl2ZSwgcmVzZXRPcmRlcnM6IGJvb2xlYW4sIHJlc2V0U2l6ZXM6IGJvb2xlYW4pOiB2b2lkO1xuICAgIHNob3dBcmVhKGNvbXBvbmVudDogTXR4U3BsaXRQYW5lRGlyZWN0aXZlKTogdm9pZDtcbiAgICBoaWRlQXJlYShjb21wOiBNdHhTcGxpdFBhbmVEaXJlY3RpdmUpOiB2b2lkO1xuICAgIGdldFZpc2libGVBcmVhU2l6ZXMoKTogTXR4U3BsaXRPdXRwdXRBcmVhU2l6ZXM7XG4gICAgc2V0VmlzaWJsZUFyZWFTaXplcyhzaXplczogTXR4U3BsaXRPdXRwdXRBcmVhU2l6ZXMpOiBib29sZWFuO1xuICAgIHByaXZhdGUgYnVpbGQ7XG4gICAgcHJpdmF0ZSByZWZyZXNoU3R5bGVTaXplcztcbiAgICBfY2xpY2tUaW1lb3V0OiBudW1iZXIgfCBudWxsO1xuICAgIGNsaWNrR3V0dGVyKGV2ZW50OiBNb3VzZUV2ZW50IHwgVG91Y2hFdmVudCwgZ3V0dGVyTnVtOiBudW1iZXIpOiB2b2lkO1xuICAgIHN0YXJ0RHJhZ2dpbmcoZXZlbnQ6IE1vdXNlRXZlbnQgfCBUb3VjaEV2ZW50LCBndXR0ZXJPcmRlcjogbnVtYmVyLCBndXR0ZXJOdW06IG51bWJlcik6IHZvaWQ7XG4gICAgcHJpdmF0ZSBkcmFnRXZlbnQ7XG4gICAgcHJpdmF0ZSBzdG9wRHJhZ2dpbmc7XG4gICAgbm90aWZ5KHR5cGU6ICdzdGFydCcgfCAncHJvZ3Jlc3MnIHwgJ2VuZCcgfCAnY2xpY2snIHwgJ2RibGNsaWNrJyB8ICd0cmFuc2l0aW9uRW5kJywgZ3V0dGVyTnVtOiBudW1iZXIpOiB2b2lkO1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQ7XG59XG4iXX0=